{
    "target": "com.apple.filesystems.apfs",
    "total": 1129,
    "version": {
        "max": "22.6.0",
        "min": "22.0.0"
    },
    "signatures": [
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_ier_log_level",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "!swc_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "%s:%d: Starting ThreadPool\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "swcrypto_threadpool_init",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Failed to allocate IORecursiveLock for the ThreadPool\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_swcrypto_threads",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: %u threads would be used for the ThreadPool\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Could not start ThreadPool kernel thread\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "swcrypto_worker",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_kernel_thread_start"
                },
                {
                    "string": "apfs-lock-group",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_grp_alloc_init"
                },
                {
                    "string": "apfs-lock-rw-group",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_grp_alloc_init"
                },
                {
                    "string": "apfs-lock-spin-group",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_grp_alloc_init"
                },
                {
                    "string": "hw.ncpu",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_sysctlbyname"
                },
                {
                    "string": "%s:%d: could not get number of cpus.  using a default of 4.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_jhash_init",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_internal_module_resources",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Not enough bytes are marked as unwritten to adjust byte counter by %zu \" \"when trying to %s list entry for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Not enough bytes are marked as unwritten to adjust byte counter by %zu when trying to %s list entry for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_adjust_unwritten_bytes_counter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_adjust_unwritten_bytes_counter",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Underflow detected in unwritten ranges counter when trying to %s list entry for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_decrement_unwritten_ranges_counters",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_decrement_unwritten_ranges_counters",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Bogus entry %p for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Zero-length range at offset %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: range %lld,%lld,%d overlaps with offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: %d range start %lld is not aligned\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: size %lld of the %d range starting at offset %lld is not aligned\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: expected %d, got %d reserved ranges\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: expected %lld, got %lld reserved bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: expected %d, got %d unwritten ranges\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s:%d - inode %lld: expected %lld, got %lld unwritten bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"APFS range list verification for inode %p has failed\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_verify_rangelist",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%02hhx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_authapfs_hexdump_hash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: hash mismatch! expected: %s, actual: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "authapfs_validate_node_hash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't read hashed node (%llu) without a hash argument\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "authapfs_validate_node",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "can't validate modified node %p (oid:%llu, xid:%llu) of fs %p (%llu). imo xid: %lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_authapfs_seal_is_broken"
                },
                {
                    "string": "subtype",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIjEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "com.apple.apfs.hash_violation.bt_node",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc"
                },
                {
                    "string": "%s:%d: %s BT node sanity check failed for node type %u subtype %u oid %llu with mask 0x%x!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "btree_node_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_btree_node_init_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get integrity meta, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume was marked for revert while mounted RO, skip revert to xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s was asked to revert to snapshot w/xid %llu but got error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not locate old super block w/sblock_oid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s must mount read-write after revert to unsealed snapshot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s using fext tree oid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s can't revert-to-xid %llu while snapshot %s with xid %llu is mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Reverting to snapshot w/xid %lld and old sblock oid %lld.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s could not start txn to revert to snapshot w/xid %lld : txerr %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s unable to modify the apfs object (err %d) to be able to revert the fs.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to mark doc-id index for rebuild (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s waiting for snapshot deletion to finish (id %lld) failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s DONE reverting to snapshot w/xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to update cached integrity meta, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_revert_to_snapshot",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "authapfs_integrity_meta_cache",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authapfs_integrity_meta_cache",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s obj_modify failed - %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_create failed - %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authapfs_integrity_meta_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to mark apfs object for modifications - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s integrity protection will be disabled (from xid: %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_authapfs_seal_break",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to load the fsroot tree - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s broken in xid: %lld, fsroot tree xid: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s integrity protection will be re-enabled\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_authapfs_seal_restore",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_unmount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot access integrity object - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "authapfs_seal_is_broken_full",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authapfs_seal_is_broken_full",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: using 8k root hash\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: using 16k root hash\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_authapfs_select_root_hash",
            "prototype": "",
            "backtrace": [
                "_authenticate_root_hash"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "authapfs_integrity_meta_get_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authapfs_integrity_meta_get_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s doc-id tree creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "doc_id_tree_create",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create doc-id tree, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s created doc-id tree, oid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_create_doc_id_tree_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unsupported tree type, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get doc-id tree key count, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get doc-id tree, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s stop background work requested, stopping tree destroy, prev %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s not enough space to enter transaction\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove first, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_doc_id_tree_destroy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s doc-id tree (oid %llu, flags 0x%llx) is not encrypted but volume is encrypted (fs_flags 0x%llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s failed to get doc-id tree (oid %llu, type 0x%x), error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s doc-id index needs rebuild, doc_id_index_flags 0x%x, role %u, doc_id_index_xid %llu, expected_xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "mark_doc_id_index_for_rebuild_if_needed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s doc-id index is stale (apfs_doc_id_index_xid %llu, expected xid %llu), but volume is RO\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_mark_doc_id_index_for_rebuild_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Cannot install APFS device switch - got %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "-apfs_no_bc_defrag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "apfs: bootcache defrag disabled by bootarg\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "-apfs_flink_panic",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "apfs: bootarg_firmlink_destitch_panics by bootarg\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: apfs: failed to vfs_fsadd myself! (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "install_apfs_vfs_fs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: done registering sysctls.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_sysctl_register",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_rangelist_verification",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                }
            ],
            "symbol": "__ZL21external_module_allocv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs-raw-device.%d.%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_devfs_make_node"
                },
                {
                    "string": "%s:%d: %s Cannot create DevFS node for inode %lld on %s@%s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Inode %lld on %s@%s cannot be used because it has been cloned\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Enable bypass mode on inode %lld on %s@%s as %d.%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_rawdev_create",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Disable bypass mode on inode %lld as %d.%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_rawdev_destroy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_rawdev_destroy",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Disabling device %d.%d because %s@%s is unmounting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "apfs_rawdev_disable_devices_for_unmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "pfkur_pause",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: Trying to unmount swap mount point, error = EBUSY\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: vflush failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: root vnode is busy\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fake mount going away\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "unmount_wait_(un)mount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "unmounting",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s resizing will be cancelled as the volume is encrypted and will no longer be accessible\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "unmount_wait_jhashused",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s apfs: unmount: did not have and could not load the root vnode! (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ungraft failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vflush failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s waiting for purgatory cleaner to finish\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs-purgatory-cleaner-finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s waiting for crypto hash cleaner to finish\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_wakeup"
                },
                {
                    "string": "apfs-cryptohash-cleaner-finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_wakeup"
                },
                {
                    "string": "%s:%d: %s pause_encryption_rolling_thread failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s second vflush failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s root vnode is busy\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s danger!!! xattr_io_vnode is still lingering...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to finish all transactions before unmount! (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_kext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_update_last_modified_by"
                },
                {
                    "string": "%s:%d: %s snapshot deletion completed on the livefs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_num_vols_mounted is %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: all done.  going home.  (numMountedAPFSVolumes %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fusion_purge_mover_queue",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_apfs_vfsop_unmount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Device %d.%d is not ready to accept IO requests - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_rawdev_strategy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read %d blocks from %lld on %s - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_rawdev_read_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Why did %p gave me extent %lld @ %lld for LBA %lld?\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Cannot write %d blocks to %lld on %s - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Why did you give me extent %lld @ %lld for LBA %lld?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_rawdev_strategy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "rawext->lba >= (prev->lba + prev->blkcnt)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                }
            ],
            "symbol": "_apfs_rawdev_collect_extents",
            "prototype": "",
            "backtrace": [
                "_apfs_rawdev_create",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs: can not determine device block size.  assuming 512.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: apfs: can not determine device block size.  assuming 512.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_vnode_dev_block_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't get features for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get features for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't get writable for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get writable for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't get issolidstate for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get issolidstate for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_vnode_dev_features",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't get block count (%s) from device\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get block count (%s) from device\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_vnode_dev_block_count",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s device accelerated crypto: %d (compiled @ %s %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "dev_init",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s device accelerated crypto: %d (compiled @ %s %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %s device_handle block size %d block count %lld features %d %s %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s device_handle block size %d block count %lld features %d %s %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_dev_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s buf_biowait() failed, error = %d, b_error = %d, buf_flags_after_io = 0x%x, crypto = [%s %s %s], get_blk_error = %d, buf_valid = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: buf_biowait() failed, error = %d, b_error = %d, buf_flags_after_io = 0x%x, crypto = [%s %s %s], get_blk_error = %d, buf_valid = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_buf_bread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s _vnode_dev_write: zeroing conversion offset for block %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: _vnode_dev_write: zeroing conversion offset for block %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__vnode_dev_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs-sync",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_buf_flushdirtyblks"
                }
            ],
            "symbol": "_vnode_dev_barrier",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"vp %p has type %d which is NOT right (orig_vp %p crypto %p crypto->owner %p)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"nx_buf_bread: cred != NOCRED \\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"nx_buf_bread: write not allowed! \\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"can not do encrypted i/o with a null cpx! crypto state %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_nx_bio_doread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s vnode_dev_read: zeroing conversion offset for block %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: vnode_dev_read: zeroing conversion offset for block %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__vnode_dev_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "dev-trim-flush-wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s trim'ing %d blocks from trim_list failed w/: %d (entry %lld:%lld ; %lld:%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: trim'ing %d blocks from trim_list failed w/: %d (entry %lld:%lld ; %lld:%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__vnode_dev_unmap_flush_and_unlock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't get cryptotype for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get cryptotype for device (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_vnode_dev_encryption_type",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Detected xid change: %llu -> %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't get tree at oxid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't get doc-id tree (oid %llu) at oxid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't lookup snap_meta for xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't load superblock for xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't load fext tree for xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Detected xid change: %llu -> %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't create mcp map btree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: tree iter init failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't validate key/val, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't lookup skey %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't insert mapping into tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Hit the MCP map limit! %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: tree iter next failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: key compare hit %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: doc-id key compare hit %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Hit %d advancing ti[0]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Hit %d advancing ti[1]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Returning %d...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Hit unexpected key type %u, obj_id 0x%llx, delta_type %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: bad block alignment obj-id: %llu laddr: %llu len: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fext[1].logical_addr=%llu, bsize=%llu, fext[1].phys_block_num=%llu, cursor=%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get snap_meta obj for %lld, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get superblock %lld of snapshot %lld, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get integrity_meta obj, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't replicate volume/snapshot with a broken seal\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get oid %llu/%llu (root %llu), err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Node %llu/%llu has non-zero header\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: bad fext @ dstream_id %llu cursor %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: dstream %llu's first extent starts at %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: found gap: dstream_id %llu cursor %llu, fext dstream_id %llu laddr %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: found gap in hole in dstream %llu between %llu and %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient22methodDeltaCreateChunkEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Can't prepare, volume is mounted/deleting/restoring\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't prepare, volume is deleting/restoring\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Only 4k containers supported for now\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't do delta snapshot replication on sealed volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find sme for base uuid %s, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find snap_meta for base xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Base snapshot in purgatory!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Base snapshot is dataless!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't load base sb (xid %llu): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "live_%s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s Couldn't find sme for target uuid %s, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find snap_meta for target xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Target %llu <= base %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Target snapshot in purgatory!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Target snapshot is dataless!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't load target sb (xid %llu): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer18deltaCreatePrepareEjPP18delta_create_ctx_tPKhS4_",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient24methodDeltaCreatePrepareEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Bogus alloc estimate: %u %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't enter a tx, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get fs_root tree, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s start write err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s too small, op=%u sz=%u remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ignore EILSEQ\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bad op in authapfs stream, %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s doc_id EILSEQ\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: crypto_rewrap EILSEQ\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s crypto EILSEQ\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s delete EILSEQ: klen=%u unsafe_buf_remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s insert EILSEQ: klen=%u vlen=%u unsafe_buf_remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s write EILSEQ: tmp_op->op_write.len=%u unsafe_buf_remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bad op in stream, %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s integrity EILSEQ: unsafe_buf_remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s integrity ENOTSUP: seal is broken\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s node EILSEQ: unsafe_buf_remain=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unrecognized op type: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Validation err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: doc-id mapping restore failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't rewrap a key (src %llu, dst %llu, class %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't flush write buf, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't set dstream crypto (ekwk %llu, class %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream fixup failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s insert failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s remove failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s alloc estimate was 0, but chunk contained a write\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bad write order cid:%llu claddr:%llu id:%llu laddr:%llu len:%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Write) free id:%llu pos:%llu len:%u failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s write failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Write) update extentref tree failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Write) ... and freeing the blocks failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't increment crypto refcnt %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fext tree insert failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bad free order cid:%llu claddr:%llu id:%llu laddr:%llu len:%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Free) free id:%llu pos:%llu len:%llu failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Mitmatching clone laddrs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Clone) free id:%llu pos:%llu len:%llu failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (Hole) free id:%llu pos:%llu len:%llu failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Too many integrity objects in stream\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get integrity meta object, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s integrity meta obj size mismatch\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't modify integrity object of outer volume, err=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s node oid out of order: expected %llu, not %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid %llu seems to exist, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't allocate block, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert omap entry for oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s EILSEQ %u %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Hit err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: couldn't alloc space: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "delta_kext_io_write_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Exceeded max_size\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "delta_kext_io_write",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Volume role %d does not support doc-id tree\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Could not create doc-id tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Could not insert doc-id mapping, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Could not delete doc-id mapping, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Invalid subtype, %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: dest ekwk_id %llu lookup hit err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: source ekwk_id %llu lookup hit err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't rewrap ekwk id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't insert ekwk id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't unwrap ekwk id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't unwrap ek id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't generate a new skey, id %llu class %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't insert ekwk skey id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s key_val_to_jobj() returned NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Hit malformed dstream in ino %llu, sz %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create/update ekwk for inode %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s jobj_to_key_val() failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s jobj_to_key_val() returned unexpected klen %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Hit malformed xattr for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s last_seen_inode_id %llu != %llu? Badly ordered ops?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create/update ekwk for xattr id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: clone iter failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: clone iter cb failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: clone iter cb failed to clone entire range id:%llu off:%llu len:%llu remain:%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient23methodDeltaRestoreChunkEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't update superblock, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s clone_fs failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Success! we finalized the snapshot, snap_xid=%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed compatibility check! %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find highest jobj id: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bad next_obj_id in stream\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree lookup failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s key too small: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient26methodDeltaRestoreFinalizeEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Can't restore to a sealed volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid op_begin, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s target uuid seems to exist, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s target name seems to exist, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Stream is incompatible with volume, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Dest volume shouldn't have snapshots...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get extentref tree, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s This volume seems to have data blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Lookup on extentref tree returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't clear fs root: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to lookup base xid %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to revert to base xid %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't create integrity meta obj, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get fsroot tree, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete old fsroot tree, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer19deltaRestorePrepareEjPP19delta_restore_ctx_tPK16delta_op_begin_ty",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient25methodDeltaRestorePrepareEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: flush failed! %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: spaceman free failed! %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_kext_io_write_finish",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to perform a MT map lookup for an extent 0x%llx, %llu in APFS Fusion: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "delta_kext_io_read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Hit fext without tweak or crypto_id, id %llu laddr %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't lookup crypto_state for %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: read err %d, paddr %llu, len %u, tweak %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_emit_dstream_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Fetch cpx failed, ekwk %llu ek %llu paddr %llu tweak %llu err %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to read %llu,%u %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get/unwrap ekwk in crypto_id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get wrapped ek in crypto_id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't unwrap ek in crypto_id %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_kext_io_read_flush",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: read flush failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "delta_kext_io_read_finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_kext_io_read_finish",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Err looking up mapping for %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "delta_lookup_mcp_mapping",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_lookup_mcp_mapping",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "delta_unlock_volume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_unlock_volume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s delta_kext_io_write_synchronous threw %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't alloc space, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_kext_io_write_flush",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't interpret class %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't create ekwk id %llu prot %u, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update refcnt on %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_restore_create_or_update_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: iterate_jobjs_with_hint() failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: delta_restore_delete_dstream_range_iter returned an error, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_restore_delete_dstream_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Couldn't split fext...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't dereference phys range %llu %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't remove fext\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %sreferencing crypto_id %llu failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_restore_delete_dstream_range_iter",
            "prototype": "",
            "backtrace": [
                "_delta_restore_delete_dstream_range"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to increment crypto_id (%llu) refcnt from dstream %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to reference phys range %llu:%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to insert new fext, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_restore_clone_dstream_range_iter",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient23methodDeltaRestoreChunkEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Megamount flag mismatch\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Snapshot delta restore not supported on MCP volumes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delta_restore_verify_compatibility",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Couldn't remove obj: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_delta_restore_nuke_volume_iter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__delta_restore_nuke_volume_iter",
            "prototype": "",
            "backtrace": [
                "__ZN18AppleAPFSContainer19deltaRestorePrepareEjPP19delta_restore_ctx_tPK16delta_op_begin_ty",
                "__ZN19AppleAPFSUserClient25methodDeltaRestorePrepareEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s bad smeo for %llu: v: %u xid: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_lookup_snapshot_metadata_ext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_lookup_snapshot_metadata_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s snap_name='%s' snap_xid %lld extentref oid %lld sblock oid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Inserting snap_name failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Inserting snap_meta failed, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_insert_snapshot_metadata",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.os.update-",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "___strlcpy_chk"
                }
            ],
            "symbol": "_construct_root_snapshot_name",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't find snap_meta for xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_lookup_snapshot_metadata_by_xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_lookup_snapshot_metadata_by_xid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't find name for snap_xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to remove snap_name record!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to remove snap_meta record!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_remove_snapshot_metadata",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s remove_jobj(old-snap-name) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_update_snap_metadata() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_rename_snapshot",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "snapxid.",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_memcmp"
                }
            ],
            "symbol": "_fs_snapshot_is_reserved_name",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s free'ing extents in main extentref tree %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_revert_extents_to_snapshot",
            "prototype": "",
            "backtrace": [
                "_revert_to_snapshot"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't lookup snap_xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.apfs.purgatory.",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_memcmp"
                },
                {
                    "string": "%s:%d: %s processing snap xid %llu...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_snap_delete_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_assert_wait"
                },
                {
                    "string": "%s:%d: %s done processing snap xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s find_prev_snapshot hit %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find this snap metadata, xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not delete snapshot w/xid %lld, merge in progress due to previous snapshot deletion\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not find previous snapshot for xid %lld, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snap %llu isn't in purgatory or pending dataless (?)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snap %llu has make_dataless, but already is dataless! (?)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find next snapshot xid, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get current extentref tree, oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find next snap metadata cur:%llu next:%llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get next extentref tree, oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_key_count() err %d for cur_tree, oid 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_key_count() err %d for next_tree, oid 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s merge, src_snap_xid %llu, dest_snap_xid %llu, cur_tree_count %llu, next_tree_count %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "forward",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "backward",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fs_tx_enter failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Not enough space to free a single block\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't modify source extentref tree, oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update source snapshot's metadata, xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't modify destination extentref tree, oid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update destination snap metadata, xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Got error %d processing extentref tree, snap_xid %llu, oid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** falling back to removing extents safely\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error processing blocks from snap xid %llu into snap xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_key_count() err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Finished processing source snap extentref tree, snap_xid %llu, oid %llu, but it still has entries!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get clone superblock (oid %llu) to check sealed status, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_tx_enter err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't make snap metadata dataless, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete fext tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete pfkur tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete snap meta records, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete source extentref tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update next snap meta, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete clone superblock, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete omap snapshot, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_iterator_init() on delta_tree (oid %lld) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ### found bogus extentref tree entry with pbn %lld (0x%llx) len_and_kind=0x%llx owning_obj_id=%lld refcnt=%d, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update an extent in delta_tree (oid %lld), err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete an extent from delta_tree (oid %lld), err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found bogus extentref tree entry with len_and_kind=0x%llx owning_obj_id=%llu refcnt=%d, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s [rate-limiting bogus extentref tree entries]",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_update_phys_range() on next_tree (oid %lld) returned %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get next pext in delta tree, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found %u bad pexts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove the first phys extent in delta tree oid %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** found bogus extentref tree entry with pbn %lld (0x%llx) len_and_kind=0x%llx owning_obj_id=%lld refcnt=%d, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "omap_snapshot_delete",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_cleanup_purgatory_continuation",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s%s%llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s Couldn't rename snap %llx to %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "move_snapshot_to_purgatory",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_move_snapshot_to_purgatory",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s A snapshot disappeared (?) at %u of %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_calculate_snapshot_range_space_usage",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_calculate_snapshot_range_space_usage",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s snapshot is dataless\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get snapshot extentref tree, oid %lld, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_snapshot_tidemark",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s name is bad, name_len=%lu name[0] = %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s tx_finish returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_tx_enter returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't clone superblock, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't insert snapshot metadata, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't create new extentref tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get existing fext tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't copy fext tree into new object, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get existing pfkur tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't copy pfkur tree into new object, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create snapshot: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't insert snap_meta_ext for snap_xid %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error: fs_tx_leave_ext returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clone_fs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get root-snapshot-name from DT\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot get integrity object - %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "root-snapshot-name",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                }
            ],
            "symbol": "_fs_lookup_root_snapshot_xid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tree creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "create_empty_extentref_tree",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_create_empty_extentref_tree",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s free'ing allocated extents for snap_xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "revert_extents_iterator",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_revert_extents_iterator",
            "prototype": "",
            "backtrace": [
                "_revert_extents_to_snapshot",
                "_revert_to_snapshot"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get the snapshot blockref tree for delta_tree_oid %lld!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s processed %d extents and free'd %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_free_allocated_snapshot_extents",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s find_next_snap(%llu) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snap xid %llu is an orphan... moving it to purgatory\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't move snap xid %llu to purgatory, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_orphan_snap_check_iterator",
            "prototype": "",
            "backtrace": [
                "_find_and_destroy_orphaned_snapshots"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s couldn't get tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't delete tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_delete_extentref_tree",
            "prototype": "",
            "backtrace": [
                "_clone_fs"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Hit err %d on obj_create, couldn't clean up tree (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_gbitmap_create",
            "prototype": "",
            "backtrace": [
                "_er_state_init"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Can't get tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Tree iteration threw %d at cursor %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Tree delete oid %llu threw %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_gbitmap_reap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tree_lookup for dstream %lld failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s0x%llx-0x%llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "tmp-ino-defrag-",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s apfs_realloc_range: physical space inconsistency. Data copy %d of offset 0x%llx length 0x%llx would have used too much space. Need 0x%llx have 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Refusing to reallocate ino %llu offset %lld len %lld - found missing pext!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s defragging a graft file, ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to insert new range (%lld)->(%lld, %lld) to blockmap lut, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_reallocate_range about to return -1! Oops!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_rr: cleanup first failed to adjust extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_rr: cleanup last failed to remove extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_rr: cleanup 0 failed to remove extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_rr: cleanup %d failed to restore extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_rr: cleanup phys failed to dereference storage, extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_reallocate_range",
            "prototype": "",
            "backtrace": [
                "_handle_reallocate_file",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to start async read (paddr %llu, len %u): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s main: timed out waiting for data (paddr %llu, len %u): error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s main: async read failed: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write data (paddr %llu, len %u): error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s write took > timeout (paddr %llu, len %u): exiting early\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "apfs-reallocate-range-read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_apfs_rr_move_data",
            "prototype": "",
            "backtrace": [
                "_apfs_reallocate_range",
                "_handle_reallocate_file",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Invalid state (on callback) for I/O context: %u\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_rr_async_read_callback",
            "prototype": "",
            "backtrace": [
                "_apfs_rr_move_data",
                "_apfs_reallocate_range",
                "_handle_reallocate_file",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Invalid state (on main) for I/O context: %u\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_rr_handle_async_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to get extentref tree: err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to lock physical extent range [%llu, %llu]: err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to lookup physical extent starting at %llu: err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_rr_should_defrag_phys_extents",
            "prototype": "",
            "backtrace": [
                "_apfs_reallocate_range",
                "_handle_reallocate_file",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_generate_fragmentation_histogram",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tsleep"
                },
                {
                    "string": "%s:%d: %s apfs_do_scan_for_fragmentation for volume %s inode %llu failed: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_fragmentation_histogram_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fragmentation_histogram_cb",
            "prototype": "",
            "backtrace": [
                "_fragmentation_histogram_fill"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid number of blocks needed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid arguments: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "len = 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "buffer = NULL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update the EFI record, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer17containerEFIEmbedEPKvy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s sending lowdisk notification: %u for with apfs_lowdisk_status: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_lowdisk_check_volume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_lowdisk_check_volume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed: cksum 0x%016llx, oid 0x%llx, type 0x%x/0x%x, size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_checksum_verify_phys",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_checksum_verify_phys",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_check_superblock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_nx_check_superblock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": ".text",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                }
            ],
            "symbol": "_EfiGetAPFSDriverVersion",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: can not find media key, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS set_last_user returned 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS set_last_user succeeded\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "-apfs_newvf_enabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                }
            ],
            "symbol": "_aks_cache_media_key",
            "prototype": "",
            "backtrace": [
                "_handle_unmount_crypto_hint",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"HW CRYPTO: [media unwrap]: CP_RAW_KEY_WRAPPEDKEY is NOT set\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_load_wrapping_key",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: FDE_get_vek for volume %s failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: cst_from_fvkey failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: rearm booter key, uuid %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: IOBSDNameMatching(%s) Failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: IOService::copyMatchingService Failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "getKey",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSSymbol17withCStringNoCopyEPKc"
                },
                {
                    "string": "CSFDETargetVEKID",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: GET_MEDIA_ENCRYPTION_KEY_UUID failed to return valid UUIDs err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "/IOResources/AppleFDEKeyStore",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15IORegistryEntry8fromPathEPKcPK15IORegistryPlanePcPiPS_"
                },
                {
                    "string": "%s:%d: Failed to get keyStore service",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: uuid_parse failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKSGetKey failed with err 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Invalid vek length %u, should be %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_keybag_import",
            "prototype": "",
            "backtrace": [
                "_apfs_meta_crypto_state_init"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: mediak key migration is not supported when rooted from ramdisk\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS Service is not available\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS migrate_media_key_to_class is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: successfully fetched wrapped key (uuid = %s, new_tag = %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get wrapped media key (uuid = %s, cur_tag = %d), error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to migrate key (uuid = %s)  [cur_class = %d, cur_tag = %d] to [new_class = %d, new_tag = %d], error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to delete container's key (uuid = %s, cur_tag = %d, cur_class = %d), error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to store container's key (uuid = %s, new_tag = %d, new_class = %d), error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s no real media key to migrate, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s media key migration when rooted from ramdisk is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s no media keys to migrate\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s media key migration failed for AES, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient31methodContainerMigrateMediaKeysEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to initialize volume keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get apfs volume keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_keybag_get",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to setup keybag for placeholder nx, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to setup placeholder nx keybag iterator, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not get volume key\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not get unlock records\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not create placeholder apfs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to setup placeholder apfs keybag iterator, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to unlock the volume, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_iokit.cpp",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "__ZL29get_vek_from_placeholder_data9klckr_ctxPhP2nxP13aks_fv_data_sP12crypto_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: vek was cached, so keep volume bag loaded\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: call to unload volume class keys does not exist\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to find volume key to unload class keys, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to unload volume class keys, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: successfully unloaded volume class keys\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_unload_class_keys",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: call to load volume class keys does not exist\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to find unlock record to load class keys, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to find volume key to load class keys, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to load volume class keys, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: successfully loaded volume class keys\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_keybag_load_class_keys",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: unlock succeeded, but failed to fix-up and replace stale-invalid wvek with committed-proposed wvek, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to unwrap proposed volume key, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to unwrap volume key, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_unlock_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s: mgc = %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s: kcnt = %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s: gid = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s: ksz(%u) too large for volume %s at offset = %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s: ksz = %u for volume %s at offset = %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_uuid_unparse"
                },
                {
                    "string": "%s:%d: KEXT_VBI: received unexpected blob from efi\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_is_efi_blob_with_keys",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_is_efi_blob_with_keys",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to add apfs unlock records range in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_keybag_create",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to get unlock record's aks state, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to remove unlock record's aks state, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to update nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_aks_remove_unlock_records",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to retain unlock record's aks state, error = 0x%x",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_keybag_aks_retain_unlock_record_for_volumes_group",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to remove previously retained unlock record's aks state, error = 0x%x",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_aks_retain_unlock_record_for_volumes_group",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient28methodVolumeAddUpdateRecordsEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS failed to retain kek for uuid = %s, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_keybag_iter_next"
                },
                {
                    "string": "apfs_keybag_aks_retain_unlock_records",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_keybag_iter_next"
                }
            ],
            "symbol": "_apfs_keybag_aks_retain_unlock_records",
            "prototype": "",
            "backtrace": [
                "__ZN18AppleAPFSContainer12volumeCreateEPK19apfs_format_optionsjPj"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: Invalid data1 key length %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Invalid data2 key length %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid operation on vm/recovery/preboot/installer/diagnostics/xart volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to remove marked unlock records, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot add a hint, there is no wkek associated to it, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not create kek and vek without a secret\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get wkek len from AKS (%ld): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get wvek len from AKS (%ld): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to lookup existing wvek for uuid = %s, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to fix-up and replace stale-invalid wvek with committed-proposed wvek, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to lookup sibling wvek for uuid = %s, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to find existing wkek, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to generate new kek, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to generate new vek, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to commit new kek bound vek, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to generate new sibling vek, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to commit new sys bound vek, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to store vek into crypto state, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"HW CRYPTO: [create]: CP_RAW_KEY_WRAPPEDKEY is NOT set\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to get wkek len from AKS (%ld): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to lookup rec to re-wrap, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to re-wrap, err = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to add/update unlock record in apfs keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"failed to commit updated wkek record, err = 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: failed to add/update wvek record in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS failed to prepare for authrestart, error = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS is not configured to prepare for authrestart\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_set_create_update_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to remove marked for removal unlock records, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to lookup unlock record in apfs keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to add marked for removal record to apfs keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_remove_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to aks remove unlock records, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to aks remove marked unlock records, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to wipe unlock records in apfs keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to destroy apfs unlock records range in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to remove vek state, error = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: removed vek state\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get volume key, error = %d, tag %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete volume key, error = %d, tag %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to fetch ER state object: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s encryption rolling state exists to be cleaned up\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to delete encryption rolling recovery data: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get bitmap for deletion: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ER state object with no bitmap??\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s deleting encryption rolling block state bitmap\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s deleting encryption rolling state object\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s removed key for volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to delete unlock records, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s removed unlock records for volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_meta_crypto_state_destroy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to evict apfs keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_keybag_evict",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: failed to bind new kek to vek, error = 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_vek_reset_kek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL16apfs_vek_aks_cmdP4apfsPyPhP13aks_fv_data_sS4_jy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS fv_unwrap_media_key failed (aks_id = %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_aks_unwrap_media_noclass",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS unwrap_media_key_from_class returned 0x%x for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS unwrap_media_key_from_class succeeded for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: AKS unwrap_media_key returned 0x%x for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS unwrap_media_key succeeded for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZL16wrapping_key_getP9nx_keybagPKvtb",
            "prototype": "",
            "backtrace": [
                "__ZL21wrapping_keybag_setupP9nx_keybagPbS1_S1_PPFiS0_PKvtbEPPFiS0_S3_PtybE"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS fv_new_media_key failed (aks_id = %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_aks_new_media_noclass",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS new_media_key returned 0x%x for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS new_media_key succeeded for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: AKS new_media_key_wrapped_by_class returned 0x%x for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: AKS new_media_key_wrapped_by_class succeeded for tag = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZL16wrapping_key_setP9nx_keybagPKvPtyb",
            "prototype": "",
            "backtrace": [
                "__ZL21wrapping_keybag_setupP9nx_keybagPbS1_S1_PPFiS0_PKvtbEPPFiS0_S3_PtybE"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": " - will replace",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to wipe %s keybag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: wiped %s keybag\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: unable to write %d-byte %s keybag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: wrote %s keybag (v%d, %d keys, %d bytes)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZL16keybag_operationP9kb_accessP12keybag_entryS2_b",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "APFS/effaceable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL16keybag_operationP9kb_accessP12keybag_entryS2_b"
                }
            ],
            "symbol": "__ZL22media_keybag_operationP9nx_keybagP12keybag_entryS2_y",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s storage overflow (size=%d avail=%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "aes_kb_put",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL10aes_kb_putP9kb_access",
            "prototype": "",
            "backtrace": [
                "__ZL22media_keybag_operationP9nx_keybagP12keybag_entryS2_y"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: dev_read_data failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Checksum failure\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s: version error, bag->mk_obj.o_type %u != %u and %u, or locker->kl_version %u != %u, or size %lu != keybag_version_upgrade %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %d >= %lu && %d <= %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL16container_kb_getP9kb_accessPb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: output buffer too small: len %zu, must be at least %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "container_keybag_lookup_record",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL30container_keybag_lookup_recordP9nx_keybagPKhiP13aks_fv_data_s",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: attempt to unwrap with stashed kek, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_keybag_unlock_record_tag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to unwrap volume key, err = 0x%x (tag = %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL29apfs_keybag_unlock_record_tagP4apfsP13aks_fv_data_sS2_yt",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed removing marked WKEK for volume at fsindex = %d, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to enter tx to remove marked WKEK for volume at fsindex = %d, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL36apfs_keybag_aks_delete_marked_recordP4apfs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to update wvek record in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"failed to commit proposed wvek record, err = 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: failed to clean-up proposed wvek record in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to add proposed wvek record in nx keybag, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL29apfs_commit_update_volume_keyP4apfsyP13aks_fv_data_s",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS fv_set_protection cmd = %x failed with error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_vek_set_protection",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL23apfs_vek_set_protectionP4apfsPyPhP13aks_fv_data_sjy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"API misuse: WBC write should not be initiated via this function\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s The WBC area has zero length\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_place_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_remap_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: We ran out of inflight IO records (%u/%u/%u/%u/%u) trying to %s %llx, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_inflight_new_IO"
                },
                {
                    "string": "fusion_inflight_initiate_IO_int",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_inflight_new_IO"
                }
            ],
            "symbol": "_fusion_inflight_initiate_IO_int",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"File a radar against APFS Fusion: Cannot find active inflight internal %s IO for LBA %llx, length %llu.\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_inflight_remove_internal_IO",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fusion_inflight_mark_deleted_int",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_inflight_mark_deleted_int",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fusion_inflight_check_deleted_int",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_inflight_check_deleted_int",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s (pid %d) is missing base ARV snapshot entitlements\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_snap_has_base_entitlements",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: entitle / CSR checks failed \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_snap_check_arv_disabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_snap_check_arv_disabled",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.developer.vfs.snapshot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s (pid %d) is missing vfs snapshot entitlements\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_snap_has_vfs_entitlement",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Container-wide extent manipulation is in progress, cannot add snapshot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot create snapshot: rolling is active, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot create snapshot: pfkur is active, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s waiting for purgatory cleaner to finish cleaning.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs-cleaner-finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_snap_vnop_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_can_manipulate_snapshots_extents failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Tidemark for snap with xid %llu is %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_calculate_snapshot_range_space_usage(%llu) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't lookup sme for %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_snap_vnop_getattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Can't delete snapshots while volume is replicating\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't delete snapshots when snap operation is not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't delete snapshots as IS_SNAPDIR_VNODE() returned false\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't delete snapshots as name_type != snap_xid_type\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot delete snapshot '%s' because it is the default root snapshot for volume '%s'\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cannot delete snapshot '%s' because volume '%s' is set to root from it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cannot delete snapshot '%s' because volume '%s' is set to revert to it at the next mount\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s proc %s: deleting snapshot name (%.*s) w/xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cannot delete mounted snapshot '%s'\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_snap_vnop_remove",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: didn't find mounted snapshot %s on the nx_mounted_fs_head list?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_rename_snapshot('%s', %u, '%s', %u) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_snap_vnop_rename",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unsupported options (flags 0x%x)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_snap_vnop_readdir",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_snap_vnop_ioctl",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s On next mount, volume will REVERT to snapshot \"%s\" w/snap xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_snap_vnop_ioctl",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "from < ((1ULL << ((56 - 1))) - 1)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: ino %llu no fext <= %llu; %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_make_fext_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "private_id != 0xbadfa1afe1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "make_fext_riterator",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_make_fext_riterator",
            "prototype": "",
            "backtrace": [
                "_apfs_truncate_locked"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com_apple_filesystems_apfs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "AppleAPFSSnapshot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "AppleAPFSUserClient",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "AppleAPFSVolumeBSDClient",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                }
            ],
            "symbol": "__GLOBAL__sub_I_apfs_iokit.cpp",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: VEKState - fv_get_blob_state failed, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_vek_get_aks_state",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vek_get_aks_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: SiDPState - fv_get_blob_state failed, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_vek_get_sidp_state",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient24methodVolumeGetSiDPStateEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to lock container list",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "updateFusionPromotionThreshold",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_updateFusionPromotionThreshold",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: check_rootmount_qualification() returned false, refusing to load the container device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: container already loaded by pid <%d> in exclusive mode, refusing request to load the container by pid <%d> device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: refusing exclusive access to pid <%d (%s)> as other clients <%d> are actively accessing the container device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Container is already loaded with temp_xp_enable %u but requested to be %u, refusing request to load the container device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: entry->c_refcount is zero and container is not reloading, refusing request to load the container device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s container loaded with exclusive access%s by pid <%d> (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": ", without mount,",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "image-type",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "sparse",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strstr"
                },
                {
                    "string": "sparse-backend",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "DiskImageURL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "%s:%d: Decoding of url %s failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Image url %s Image path %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Image %s is a flat file, do not consider as sparse\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: lookup for %s failed with %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "file://",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                },
                {
                    "string": "%s:%d: allocating placeholder container failed, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "alloc_placeholder_nx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_container_load",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: vnode_close() invoked in the container unload path\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "container_unload",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_container_unload",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to create Snapshot object\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No volume at index %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to find containter object\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_container_create_dev_for_snapshot",
            "prototype": "",
            "backtrace": [
                "_handle_snapshot_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No volume at index %d \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to find containter object \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_container_identify_vnode_from_idx",
            "prototype": "",
            "backtrace": [
                "_apfs_vfs_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: boot from ramdisk %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "container_rootmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to find bootable volume in ramdisk %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_container_rootmount",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: No IOKit node for %d.%d to deliver notification %08x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Sending notification about %08x for APFS volume %d.%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Cannot send notification about %08x for %d.%d - this is not a volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Sending notification about %08x for APFS snapshot %d.%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Sending additional notification about %08x for the parent of APFS snapshot %d.%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Cannot send notification about %08x for %d.%d - unexpected device type\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_sendIONotification",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "AppleTDMLocked",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZNK15IORegistryEntry16propertyHasValueEPKcPK8OSObjectPK15IORegistryPlanej"
                }
            ],
            "symbol": "_apfs_iokit_mount_eligibility",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "AppleImage4",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN9IOService15serviceMatchingEPKcP12OSDictionary"
                },
                {
                    "string": "%s:%d: waitForService (AppleImage4) failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: img4_nonce_domain_copy_nonce failed with: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: img4_firmware_new returned NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to create matching dictionary for %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "waitForService_helper",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_validate_payload_and_manifest",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: load: %s, v%s, %s, %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_module_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_corruption_panics",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "hw.physicalcpu",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_sysctlbyname"
                },
                {
                    "string": "%s:%d: setting max link-id cache size to: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "CoreAnalyticsHub",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN9IOService15serviceMatchingEPKcP12OSDictionary"
                }
            ],
            "symbol": "_apfs_module_start",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: unload: %s, v%s, %s, %s (remaining mem allocated: %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_module_stop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_module_stop",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: importing root hash (basesystem ? %d)...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "import_iboot_forwarded_roothash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: apfs_extract_root_hash_and_manifest failed with error: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_import_iboot_forwarded_roothash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "IOBSD",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN9IOService16resourceMatchingEPKcP12OSDictionary"
                }
            ],
            "symbol": "_external_module_resources",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Solid State",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "Rotational",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                }
            ],
            "symbol": "_ScanForMediumType",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: unable to read fs %d superblock (OID %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                },
                {
                    "string": "probe",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                },
                {
                    "string": "%s:%d: %s Caching extended container info for container %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer5probeEP9IOServicePi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to start unmount dangling thread, error %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "terminate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer9terminateEj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: ### filtering out entry %d: 0x%llx:0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "unmap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer5unmapEP9IOServiceP15IOStorageExtentjj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "52637672-7900-11AA-AA11-00306543ECAC",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "Invalid Startup Disk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12OSDictionary12withCapacityEj"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer22setContainerPropertiesEPK2nx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: container_load failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "get_nx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer6get_nxEPK16nx_mount_optionsiiPi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs_newfs failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "volumeCreate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: current operation is not supported on %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid arguments for creating a System volume %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get sibling volume %d, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failing due to invalid role of sibling volume, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failing as sibling volume is undergoing crypto rolling, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s A Non-sealed system sybling volume is not allowed, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failing due to locked sibling volume, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failing due to sibling volume not in a volume group, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_volume_group_has_role(%s, data) failed with error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume_group %s already has a volume with system or data role\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume_group %s already has a volume with %s role\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs tree type 0x%x invalid, using virtual btree instead\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s extentref tree type 0x%x invalid, using physical btree instead\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s snapmeta tree type 0x%x invalid, using physical btree instead\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s fext tree type 0x%x invalid, using physical btree instead\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s no space for a new file system (slot %d, max %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s existing file system (slot %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create fs: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not set fs bounds for guarantee %lld and quota %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FS will NOT be encrypted.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s unable to create/store metadata crypto (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs omap initialization failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs root tree creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs snapshot metadata tree creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs pfkur tree creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs root dir creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs private dir creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update sibling volume index %d group, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to create/store data sw crypto (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to load volume class keys, error = %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s successfully loaded volume class keys\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fs creation failed: %d ... cleaning up...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete fs root tree after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete fs snap metadata tree after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete fs extentref tree after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete fs fext tree after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete pfkur tree after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to destroy omap after fs creation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to wait on reaper: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't reopen transaction to clean up: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't clean up crypto state: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer12volumeCreateEPK19apfs_format_optionsjPj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Minimal size for %lld+%lld (changing tier %d) is %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient25methodGetMinContainerSizeEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Trying to resize container to a size (%lld) smaller or equal to ssd (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "shrink",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Resize: %s [%lld,%lld] -> [%lld,%lld]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_resize is not allowed in demo mode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s resize operation is in progress\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Container-wide extent manipulation is in progress\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_spaceman_in_use_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s %s %sfusion %lld+%lld -> %lld+%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %lld -> %lld, total required metadata %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error resizing spaceman: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to load container metadata ranges (overlap?): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing old checkpoint descriptor area 0x%llx:0x%x failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing old checkpoint data area 0x%llx:0x%x failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing old spaceman IP bitmap area 0x%llx:0x%x failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing old spaceman IP area 0x%llx:0x%llx failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s flipping persistence of old spaceman free queue tree %d failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_finish failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing old spaceman free queue tree %d failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_delete"
                },
                {
                    "string": "%s:%d: %s freeing old metadata ranges tree failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s nx_resize failed with ENOSPC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Container is fused, resizing down the main tier is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_validate_and_setup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Container has fragmented metadata\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_resize_get_new_metadata_params",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_find_clear_range_for_metadata() error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s metadata_start_paddr %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s shrinking:%c retrying:%c, setting block-out prange to %llu+%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s block_out_physical_range failed with ENOSPC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Estimated minimum number of blocks to resize to is %lld, too close to (or less than) resize request of %lld blocks; re-calculating:\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Minimum number of blocks to resize to is %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Minimum number of blocks to resize to could not be calculated\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s metadata alloc order %lld %lld %lld %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "nx_resize_set_metadata_alloc_order",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s fusion_mt_free_ssd_space (%lld) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_evict_fusion_rc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Evict the whole RC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s spaceman_fq_tree_get(%d) failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't shrink max_file_systems from %u to %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s not enough free space %lld to hold new metadata %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error allocating xp desc metadata range: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error allocating xp data metadata range: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error allocating sm ip bm metadata range: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error allocating sm ip metadata range: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s find_new_metadata(): [%llx]@%llx, [%llx]@%llx, [%llx]@%llx, [%llx]@%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s find_new_metadata(): [%lld]@%lld, [%lld]@%lld, [%lld]@%lld, [%lld]@%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Could not allocate all metadata on main device\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_find_new_metadata_ranges",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s re-flipping persistence of old spaceman free queue tree %d failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_rollback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_iterate_nodes"
                },
                {
                    "string": "%s:%d: %s flipping persistence of new free queue tree %d failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_iterate_nodes"
                },
                {
                    "string": "%s:%d: %s freeing new free queue tree %d failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_iterate_nodes"
                },
                {
                    "string": "%s:%d: Eviction of %llx, %llu failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_free_ssd_space",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to allocate bitmap block from IP bitmap pool: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to initialize cab %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to initialize cib %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to read cib %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to obj_create a new spaceman structure: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to copy free queue %d tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s IP bm of current sm %lld is in cache, remove it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to write internal pool bitmap block: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cab of current sm %lld is in cache, remove it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cab is dirty after cache flush, write it now\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cib of current sm %lld is in cache, remove it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cib is dirty after cache flush, write it now\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Chunk of current sm %lld is in cache, remove it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s chunk bitmap is dirty after cache flush, write it now\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to read chunk %llu bitmap: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write chunk %llu bitmap: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_init_cab",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_init_cib",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to zero checkpoint descriptor block %d @ %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_checkpoint_desc_zero",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient21methodResizeContainerEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: containerDefrag(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "containerDefrag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Container is fused, defragmenting the main tier is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient21methodDefragContainerEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Unable to load the nx object, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to get the apfs index=%d, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL8get_apfsiP2nxPP4apfs"
                },
                {
                    "string": "%s:%d: %s tx_enter failed trying to modify apfs index=%d error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_modify failed on apfs, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to modify volume group UUID from %s to %s, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_leave failed trying to modify apfs index=%d, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_enter failed trying to modify container uuid, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_leave failed trying to modify container uuid, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient25methodContainerStampUUIDsEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid arguments: index=%u, max_count=%zu, uuids=%p, count=%p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "volumeListUUIDsOfRecords",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer24volumeListUUIDsOfRecordsEjmPA16_hPm",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid argumets: index=%u, uuid=%p, backoff=%p, locek_out=%p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "volumeGetUnlockRecordState",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient32methodVolumeGetUnlockRecordStateEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid arguments: index=%u, uuid=%p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "volumeAddUpdateRecords",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient28methodVolumeAddUpdateRecordsEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "lock_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "com.apple.private.apfs.lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient16methodVolumeLockEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: found cached efi version: %llu for container: %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s failed to read the embedded EFI, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid efi buffer size\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to allocate efi buffer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to copy efi buffer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient28methodContainerEFIGetVersionEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to get omap: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get omap tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get the node count of the omap tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get extentref tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get the node count of the extentref tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get fsroot tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get the node count of the fsroot tree: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient20methodGetVolumeStatsEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Can't find fs_idx %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Can't find dev path for fs_idx %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: vnode_lookup(%s) err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: mac_vnode_check_open(%s) err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer14deltaAuthCheckEP2nxjb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Index %u is bogus, max %u, fs is %snull\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Vol %u is still open\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't delete fsidx %u, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't revert fsidx %u to xid %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer20deltaRestoreTeardownEP19delta_restore_ctx_t",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s AppleAPFSSnapshot::init invalid xid %llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s AppleAPFSSnapshot::init invalid snap_meta_ext\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN17AppleAPFSSnapshot4initEP18AppleAPFSContainerPK2nxPK4apfsP15j_snap_metadataP13snap_meta_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_idx %d is incompletely restored\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "createAPFSVolume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN15AppleAPFSVolume16createAPFSVolumeEP18AppleAPFSContainerPK2nxiPK4apfs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s encryption rolling in-progress -- must read through container!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN15AppleAPFSVolume4readEP9IOServiceyP18IOMemoryDescriptorP19IOStorageAttributesP19IOStorageCompletion",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s encryption rolling in-progress -- must write through container!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN15AppleAPFSVolume5writeEP9IOServiceyP18IOMemoryDescriptorP19IOStorageAttributesP19IOStorageCompletion",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "CaseSensitive",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_uuid_unparse"
                },
                {
                    "string": "PreviousRootUUID",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "IncompatibleFeatures",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_rw_lock_shared"
                },
                {
                    "string": "VolBootable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_jobj_release"
                },
                {
                    "string": "RoleValue",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN7OSArray12withCapacityEj"
                },
                {
                    "string": "Recovery",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Preboot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Installer",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Baseband data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Backup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Update",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Hardware",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "SideCar",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Enterprise data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "iDiags",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "Prelogin",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "UserData",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSString11withCStringEPKc"
                },
                {
                    "string": "%s:%d: %s nx_get_volume_group(%s) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN15AppleAPFSVolume19setVolumePropertiesEPK2nxPK4apfs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s delta_teardown_thread teardown the create ctx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "delta_teardown_thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s delta_teardown_thread teardown the restore ctx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__Z21delta_teardown_threadPvi",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient4stopEP9IOService"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not start kernel thread to terminate delta context\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not allocate argument for delta teardown thread\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient4stopEP9IOService",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: clearing volumes crypto states\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "clientClose",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient11clientCloseEv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.storage.revoke-access",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s wiping all (%d) APFS volume keys in the keybag\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "wipe_volume_keys",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s tx_leave failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient23methodContainerWipeKeysEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.securityd.stash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "AppleFDEKeyStore",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN9IOService15serviceMatchingEPKcP12OSDictionary"
                },
                {
                    "string": "setKeyGetUUID",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSSymbol17withCStringNoCopyEPKc"
                },
                {
                    "string": "%s:%d: Could not set VEK in FDEKeyStore, ioret was: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "setStashKey",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSSymbol17withCStringNoCopyEPKc"
                },
                {
                    "string": "%s:%d: Could not set FDEKeyStore stash key, ioret was: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient21methodVolumeEscrowVEKEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.keystore.filevault",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient27methodVolumeBindNewKEKToVEKEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.unencrypted.system-volume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient24methodVolumeCreateForMSUEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.apfs.wvek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient19methodVolumeGetWVEKEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "methodContainerVolumeGroupGetVolumes",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient36methodContainerVolumeGroupGetVolumesEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "methodContainerVolumeGroupGetFirmlinks",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Found %d firmlinks in group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient38methodContainerVolumeGroupGetFirmlinksEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to map crypto I/O buffer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "methodPerformCryptoIO",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient21methodPerformCryptoIOEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.key_migration",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient25methodVolumePFKTranscribeEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "boot-uuid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "apfs-preboot-uuid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "_apfs_is_root_volume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "hibernate-unlock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "_apfs_is_hibernate_unlock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "recoveryos",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL24isDTPropertyValueEqualToPKcS0_S0_"
                },
                {
                    "string": "diagnostics",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "_apfs_is_booted_for_recovery",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "/options",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL24isDTPropertyValueEqualToPKcS0_S0_"
                },
                {
                    "string": "enable-remap-mode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL24isDTPropertyValueEqualToPKcS0_S0_"
                },
                {
                    "string": "%s:%d: ================ enable-remap-mode is ON ================\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "apfs_remap_mode_is_enabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: failed to copy mount arguments: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to update mount as volume is unmounting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to update mount as volume is no longer mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "updating mounted",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s reload mounts not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vfs mount structure specifies read only but apfs mount structure doesn't\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't write-upgrade a snapshot mount\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Updating mount to read/write mode is not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Remounting system volume in read/write mode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s unable to update mount: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s revert to snapshot failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: not allowed to mount as root\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: no vnode for mountroot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to root from devvp %p (%s): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Mounting-disabled flag is set\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid arguments for mounting a filesystem\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: the conversion/crypto mount is already mounted for %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s The root snapshot is already mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: no vnode for first mount of filesystem\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to mount from %s: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid fsindex: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to mount volume for conversion, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid mount mode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: malformed arguments for image4 payload or manifest\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: image4 payload (size %llu) or manifest (size %llu) is too large\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: image 4cc (%u) is invalid \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to copy image4 payload and manifest for authenticated snapshot mount: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Validating payload and manifest for authenticated snapshot mount ...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to validate image4 payload and manifest for authenticated snapshot mount: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_mount failed, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Promoter has been locked \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to find named root snapshot: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"The global payload bytes pointer is NULL\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Failed to allocate memory while finding the root snapshot\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Failed to find the root snapshot: %s (%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to select root snapshot: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Rooting from snapshot with xid %llu.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "\"Failed to find the root snapshot: %s (%d). Rooting from the live fs of a sealed volume is not allowed on a RELEASE build\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s can't mount a filesystem being deleted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to mount livefs as volume is mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_mount_livefs failed, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs iokit node was not found\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_iokit_mount_eligibility not eligible, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s handle_*_mount failed, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot stash key - missing device information\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"unencrypted data volume is not allowed\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: apfs_vfsop_mount failed, err: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: handling conversion mount (device %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: rejecting crypto mount: OS variant is not recovery\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: not allowed to do a verification mount of %s (is_suser %s ; uid %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't mount for invert, there are volumes still mounted (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume crypto key is not cached for volume %ss%d, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to vnode_create the root vnode!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to jhash_insert the root inode, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "APFS_MOUNT_FOR_VERIFICATION",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "APFS_MOUNT_FOR_REPAIR",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s mount finished w/apfs \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "crypto",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_OSAddAtomic"
                },
                {
                    "string": "conversion",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_OSAddAtomic"
                }
            ],
            "symbol": "_apfs_vfsop_mount",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "/defaults",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                },
                {
                    "string": "no-effaceable-storage",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                },
                {
                    "string": "%s:%d: ================ no-effaceable-storage is ON ================\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "effaceable_is_disabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_effaceable_is_disabled",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "/filesystems",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                },
                {
                    "string": "DoNotUseSEP",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                },
                {
                    "string": "%s:%d: ================ insecure boot is enabled ================\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "insecure_boot_enabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_insecure_boot_enabled",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Ejectable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15IORegistryEntry16propertyHasValueEPKcPK8OSObject"
                },
                {
                    "string": "%s:%d: %s Container is Ejectable / Removable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_is_removable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_is_removable",
            "prototype": "",
            "backtrace": [
                "_nx_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "AppleKeyStoreRegistryID",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "AppleEffaceableRegistryID",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "%s:%d: %s Container has (eff = %lld, aks = %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "EFFACER_service",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__Z15EFFACER_servicePv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: key for vol uuid %s and tag %d is already cached\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cached key for vol uuid %s and tag %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_cache_key_for_uuid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: copied cached key for %s and tag %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: could not find the cached key for %s and tag %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_copy_cached_key_for_uuid",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient22methodGetSetLockerDataEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: deleted cached key for %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_delete_cached_key_for_uuid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_delete_cached_key_for_uuid",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: lookup_encryption_block_size: Found IOMedia\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: lookup_encryption_block_size: Got OSNumber\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: lookup_encryption_block_size: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No CPX??\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error modifying apfs for er state object create: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not create persistent state for enc/dec rolling: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: init: er_chunk_len: 0x%llx, er_chunk_bcount: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Could not create er bitmap with error: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not pre-allocate er bitmap with error: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create data sw crypto state, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to size main Fusion device: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Keyrolling is not supported, returning ENOTSUP.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: init: er_state_obj: 0x%llx, er_bitmap: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: init: collision: er_state_obj: 0x%llx, er_bitmap: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ignoring error while leaving tx during state obj creation: %d -> 0.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s Error leaving tx for creating state for enc/dec rolling: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_state_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: invalid parameter: root_hash? %p root_hash_size? %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "/chosen/secure-boot-hashes",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL11DT_propertyPKcS0_PP8OSObject"
                },
                {
                    "string": "%s:%d: could not retrieve %s from device tree\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to cast root_hash_blob\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_extract_root_hash_arm",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Cannot find IOService for device %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot get AppleAPFSVolume from IOService %p for device %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot get AppleAPFSContainer from AppleAPFSVolume %p for device %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot get AppleAPFSMedia from AppleAPFSContainer %p for device %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot get AppleAPFSContainerScheme from AppleAPFSMedia %p for device %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "Failed to allocate %llu bytes for hiberKey\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_IOLog"
                }
            ],
            "symbol": "_ApfsStashHiberKey",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: get_fragmentation_histogram failed to load container - %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid volume index %u \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fragmentation_histogram_fill - failed to get fs oid %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fragmentation_histogram_fill volume oid %lld (%d) is unmounted, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s fragmentation_histogram_fill volume oid %lld (%d) is unmounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fragmentation_histogram_fill called on volume oid %lld (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fragmentation_histogram_fill for volume oid %lld (%d) failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient31methodGetFragmentationHistogramEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to allocate memory for cpx, container %s, fs %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: setting crypto state for container %s fs %d by pid %d at index %d done\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN15AppleAPFSVolume9setCryptoEP3cpxPKcbi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to load placeholder nx (disk = %s), error = %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s: failed to get uuid for fs %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s: failed to get uuid c str for fs %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s: volume %d uuid is null\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not find key for volume uuid %s on container %s at fsindex %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: failed to find any encrypted volume in container %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: crypto-io mode for container %s is enabled, %d encrypted fs found\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to enable crypto-io mode for container %s: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can not unlock volume with placeholder data, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "set_crypto_with_placeholder_nxapfs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient29methodContainerEnableCryptoIOEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to get container for %s: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: crypto-io mode for container %s is disabled\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZN18AppleAPFSContainer24containerDisableCryptoIOEv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid arguments: max_count=%u, count=%p, vkrs=%p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to load container %s: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to setup keybag for placeholder container %s: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: container keybag is not initialized %s: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to setup placeholder container keybag iterator, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient33methodContainerGetKeyLockerRangesEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failing due to placeholder nx media keybag range mismatch\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to allocate keybag for placeholder nx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s keylocker prange block count is above upperbound - %llu, maximum permitted block count is %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to allocate locker data\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to map locker data\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to load keybag wrapping key for placeholder nx, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to copy locker data back into userspace, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient22methodGetSetLockerDataEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: failed to find container to determine volume lock status dev_path = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: volume is no longer locked dev_path = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: warning: could not cache vek, kek may not be stashed, error = %x dev_path = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: invalid fsindex for device = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: attempt to cache vek from stashed kek (if present) for volume %ss%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: can't load container for device = %s, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid fsoid %ss%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't load volume, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume can be unlocked during mount\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to unlock volume using stashed kek, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to store cached vek, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s successfully unlocked the volume using stashed kek\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s volume dev name unterminated / too long\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_is_vol_locked",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_is_vol_locked",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "blksize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "reserve",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "Volume count",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "Max volume count",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "__ZL20createInfoDictionaryPKcP2nxPP12OSDictionaryb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to create vnode for in-kernel mount, error = %d path = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to open vnode for in-kernel mount, error = %d path = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL14update_mntfromP5mountP7IOMediab",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "Content Hint",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZNK15OSMetaClassBase8metaCastEPKc"
                }
            ],
            "symbol": "__ZL12get_gpt_guidP15IORegistryEntry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "valid_bootable_volume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                }
            ],
            "symbol": "__ZL20pick_bootable_volumePK2nx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: img4_firmware_execute: successfully validated the payload and the manifest\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: img4_firmware_execute: failed to authenticate root-hash (error %s <%d>)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL22root_hash_execution_cbP14_img4_firmwareP11_img4_imageiPv",
            "prototype": "",
            "backtrace": [
                "_validate_payload_and_manifest"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "image-format-read-only",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZL27search_for_boolean_propertyP15IORegistryEntryPKc"
                },
                {
                    "string": "Target Disk Mode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "__ZL22_container_is_externalPvP10dev_handle",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: encrypted IO not supported during lightweight probe dev_name = %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "iokit_read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL10iokit_readP10dev_handlexmPvP12crypto_statei",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "unmount_dangling",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_thread_set_thread_name"
                },
                {
                    "string": "%s:%d: Found %d dangling mounts on %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_vfs_iterate"
                },
                {
                    "string": "container_get_dangling_mounts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_vfs_iterate"
                }
            ],
            "symbol": "__ZL34container_unmount_dangling_wrapperPvi",
            "prototype": "",
            "backtrace": [
                "__ZN18AppleAPFSContainer9terminateEj"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Found dangling mount %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "dangling_mount_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZL23dangling_mount_callbackP5mountPv",
            "prototype": "",
            "backtrace": [
                "__ZL34container_unmount_dangling_wrapperPvi",
                "__ZN18AppleAPFSContainer9terminateEj"
            ]
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "fs_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "fs_reserve",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "fs_quota",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "fs_free",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                },
                {
                    "string": "fs_used",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                }
            ],
            "symbol": "__ZL22setDictionaryForVolumeP2nxyPcP12OSDictionaryb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "VEKUserProtected",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "VEKSystemProtected",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "__ZL20getVEKStateFromCachePK12OSDictionaryPv",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient23methodVolumeGetVEKStateEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ignoring error (%d) to resume crypto on next volume from volume group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot find a IOKit service to send out notifications about changes in encryption state\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL24crypto_complete_callbackP4apfs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: container loaded in exclusive mode by pid <%d>, refusing this request to get the container by pid <%d>\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "container_get",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL13container_getPKcPi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get free extent info from spaceman, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "get_free_extents_histogram",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient28methodGetContainerHistogramsEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Invalid parameters\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "freeExtentInfoCallback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL22freeExtentInfoCallbackPvPxS0_",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient28methodGetContainerHistogramsEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Only accept buf I/O, no raw disk access\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: buff has no vnode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Wrong apfs pointer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Bad vnode type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Bad device\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Volume not mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Not a kernel I/O\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Not a kernel task\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Bad apfs object type %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL16bufattr_get_apfsP5mountP9__bufattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Virtual Interface",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strstr"
                }
            ],
            "symbol": "_nx_is_virtual",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "APFSCryptoContext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "CryptoBufferDescriptor",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "APFSOSNumberAtomic",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                },
                {
                    "string": "AppleAPFSMediaBSDClient",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN11OSMetaClassC2EPKcPKS_j"
                }
            ],
            "symbol": "__GLOBAL__sub_I_apfs_filter.cpp",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Cannot grow IOMedia beyond partition: Current sizes %lld & %lld, requested %lld & %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "resize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN14AppleAPFSMedia6resizeEyy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "input arg is a NULL pointer",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_IOLog"
                },
                {
                    "string": "Buffer is too small: %u while at least %llu was expected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_IOLog"
                },
                {
                    "string": "getHiberKey",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "__ZN14AppleAPFSMedia20callPlatformFunctionEPK8OSSymbolbPvS3_S3_S3_",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "length <= _capacity",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                }
            ],
            "symbol": "__ZN22CryptoBufferDescriptor9setLengthEm",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "enc_allocated == !!enc_ctxs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "(sbp_allocated == !!sbp_sbufs) && (sbp_allocated == !!sbp_lbufs)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "apfs_swcrypto_sbufcount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "apfs_swcrypto_lbufcount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "apfs_swcrypto_sbufsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "apfs_swcrypto_lbufsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: Using %u buffers with size %u, %u buffers size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "cryptoAlloc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "mount_apfs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_uuid_copy"
                },
                {
                    "string": "EF57347C-0000-11AA-AA11-00306543ECAC",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_uuid_copy"
                },
                {
                    "string": "Secondary",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN8OSNumber10withNumberEyj"
                }
            ],
            "symbol": "__ZN24AppleAPFSContainerScheme5startEP9IOService",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"AppleAPFSContainerScheme::acquireCryptoBuffer, could not prepare(), status = 0x%08x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "__ZN24AppleAPFSContainerScheme19acquireCryptoBufferEP17APFSCryptoContextyymPFvPvS2_iyEb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed complete(), status = 0x%08x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "releaseCryptoBuffer",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN22CryptoBufferDescriptor7ReleaseEiy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "enc_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "sbp_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                }
            ],
            "symbol": "__ZN24AppleAPFSContainerScheme13cryptoReleaseEv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Bytes (Read)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                },
                {
                    "string": "Bytes (Write)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                },
                {
                    "string": "Operations (Read)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                },
                {
                    "string": "Operations (Write)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "__ZN24AppleAPFSContainerScheme4initEP12OSDictionary",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "Whole",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "FusionMode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "__ZN24AppleAPFSContainerScheme5probeEP9IOServicePi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Shutting ThreadPool down\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "swcrypto_threadpool_shutdown",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__Z28swcrypto_threadpool_shutdownv",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "buffer",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "!buffer->_next",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "swc_queueHead != NULL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "swc_queueHead == NULL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                }
            ],
            "symbol": "__Z28swcrypto_threadpool_scheduleP22CryptoBufferDescriptor",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Controller Characteristics",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "Encryption Type",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "AES-CBC",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                },
                {
                    "string": "AES-XEX",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                },
                {
                    "string": "AES-XTS",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "__ZL13isDevHWCryptoP7IOMedia",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "swc_queueTail == task",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "%s:%d: ThreadPool worker thread is shutting down\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "swcrypto_threadpool_worker_thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__ZL33swcrypto_threadpool_worker_threadPvi",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "target == cryptoCtx->_container",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "%s:%d: Failed read request %llx, %llu: %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to read buffer for %llx: Got %llu bytes while expected %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL14completionReadPvS_iy",
            "prototype": "",
            "backtrace": [
                "__ZN24AppleAPFSContainerScheme4readEP9IOServiceyP18IOMemoryDescriptorP19IOStorageAttributesP19IOStorageCompletion"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "target == cryptoBuffer->_cryptoCtx->_container",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_Assert"
                },
                {
                    "string": "%s:%d: Failed to write buffer for %llx: Got %llu bytes while expected %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed write request %llx, %llu: %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL15completionWritePvS_iy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: directory inode NULL for KAUTH_VNODE_DELETE\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_inode_authorize_with_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_inode_authorize_with_lock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to create supplemental tree (type %d): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "supplemental_tree_create",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_supplemental_tree_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to get supplemental tree (type %d, oid %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to delete supplemental tree (type %d): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_supplemental_tree_destroy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to copy supplemental tree (type %d): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "supplemental_tree_copy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_supplemental_tree_copy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get tree (type %d, oid %llu) for reversion: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to deep copy tree (type %d, oid %llu) during reversion: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to destroy old live fs tree (type %d, oid %llu) during reversion: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reverted supplemental tree (type %d): %llu -> %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_supplemental_tree_revert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": " (%s)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_apfs_set_formatted_by",
            "prototype": "",
            "backtrace": [
                "__ZN18AppleAPFSContainer12volumeCreateEPK19apfs_format_optionsjPj"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No vnode for provided host graft inode!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft file %llu is not a regular file\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Grafting on an encrypted volume is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Number of grafts (%d) >= maximum (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft dir %llu is inside of a graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to get graft directory vnode: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft dir %llu is not a directory\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft dir %llu was deleted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Grafting compressed file %llu is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft file %llu is inside a graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft file %llu is already grafted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft dir %llu is already grafted on\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Grafting a clone, share blockmap lut with %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft file %llu has size 0\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "graft",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_mount"
                },
                {
                    "string": "%s:%d: %s Graft nx mount failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No fs oid at fs index 0 for graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft apfs mount failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Fetching the integrity object for the graft failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to authenticate root hash (volume type %d): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "Graft of an unsealed image (volume type: %d) is not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_unmount"
                },
                {
                    "string": "%s:%d: %s Graft state allocation failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft jobj id range get failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft jobj id range length %llu is smaller than graft next_obj_id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft jobj id range allocation failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft ino %llu, jobj_id range %llu+%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to generate graft dev_t: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't get extra usecount on host vnode: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Graft jobj_id range %llu+%llu overlaps existing graft range %llu+%llu, graft_dir_id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Loading fs vnodes for the graft fs failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s successfully grafted ino %llu on dir %llu, dev_name [%s]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_graft",
            "prototype": "",
            "backtrace": [
                "_handle_fsioc_graft",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s persisting %d ephemeral grafts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_graft_mount_update_ro_to_rw",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get graft file vnode, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get write graft file xattrs, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't create extentref tree for remap mode, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to persist ephemeral grafts, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get ER object during RO->RW transition: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: recover state: ro->rw : no recovered state to write out. bailing.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to write out recovered state during RO to RW transition[%d].\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: state recovery: ro -> rw: releasing extra RO reference [%llu].\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_mount_update",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Holding graft lock, but didn't expect to!\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_graft_lock_shared",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Want graft lock exclusive, but already holding it!\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_graft_lock_exclusive",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Unable to get graft's host io lock status: %d\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Holding graft's host io lock, but didn't expect to!\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_graft_lock_host_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s inode %llu is not a graft host dir!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No graft state for graft host dir %llu!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Need superuser to de-graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_fsioc_ungraft",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_fsioc_ungraft",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error %d ungrafting at dir %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_ungraft"
                },
                {
                    "string": "apfs_ungraft_all",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_ungraft"
                }
            ],
            "symbol": "_apfs_ungraft_all",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_get_graft_state_by_graft_private_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_vnode_getwithref_noblock"
                }
            ],
            "symbol": "_apfs_get_graft_state_by_graft_private_id",
            "prototype": "",
            "backtrace": [
                "_apfs_graft",
                "_handle_fsioc_graft",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_get_xattr failed for vol uuid, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid value_len (%d) for vol uuid xattr\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s graft volume uuid %s does not match host volume uuid %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_get_xattr failed for jobj id base, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid value_len (%d) for jobj id base xattr\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_get_xattr failed for jobj id len, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid value_len (%d) for jobj id len xattr\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid graft jobj id range (%llu+%llu) for apfs_next_obj_id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s graft jobj id range (%llu+%llu) overlaps existing jobj_id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to look up overlapping jobj_id for range (%llu+%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_graft_jobj_range",
            "prototype": "",
            "backtrace": [
                "_apfs_graft",
                "_handle_fsioc_graft",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s jobj id range length 0x%llx overflows next_obj_id 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write graft file xattrs, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s graft ino %llu, vol-uuid %s, allocated jobj_id range %llu+%llu (%s mount)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_allocate_graft_jobj_range",
            "prototype": "",
            "backtrace": [
                "_apfs_graft",
                "_handle_fsioc_graft",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_add_xattr failed for vol uuid, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_add_xattr failed for jobj id base, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_add_xattr failed for jobj id len, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_remove_xattr failed for jobj id base, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_write_graft_file_xattrs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No apfs pointer for graft state!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No container pointer for grafted FS!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Ungraft disallowed for this graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No parent directory available to un-graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_ungraft",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "wait_ungraft",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_mtx_lock"
                }
            ],
            "symbol": "_apfs_wait_for_ungraft_idle",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "\"%s:%u: apfs corruption detected\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "logging.c",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_log_corrupt",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"%s : Downgrading to shared but lock not held in exclusive\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_io_lock_extending_write_to_shared",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s danger! write on a dead inode (%llu)!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not create dstream for ino %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s alloc_space_for_write failed ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot find extent for offset %lld in inode %llu (%s): %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot reserve %lld bytes at offset %lld of inode %llu (%s) ret %d xid %lld (lowdisk: 0x%x) offset %lld writelimit %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate %lld bytes at offset %lld in inode %lld(%s) - %s(%d), dstream size %lld alloced-size %lld offset %lld writlim %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s **** ino %lld had to retry %d times to get into a txn\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Too many ranges in inode %lld: cannot add %lld bytes in %d ranges in the region %lld:%lld to the list\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_reserve_space",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_prepare_write_and_lock",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_write"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld has no name (parent-id %lld)!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not lookup original dir rec %lld:%s for ino %lld nlink %d iflags=0x%llx err=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create sibling link for orig_ino %lld (parent/name %lld:%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_jobj() failed trying to increment ino %lld's link count, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_jobj() failed trying to increment ino %lld's children count, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert hardlink drec %lld:%s for file-id %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_link",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %llu: failed to modify the finder info xattr while unsetting the UF_HIDDEN bsd flag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_set_bsd_flags",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove extents of file %lld (rret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_tx_enter failed (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Bogus combination - old size %lld, new size %lld for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to grow %lld to %lld (new_end_size == 0) error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot grow inode %lld to %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot zero out [%lld, %lld) of ino %llu; old_eof=%lld, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "!apfs_is_sealed(apfs)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino_is_file(ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fsize_valid(new_size)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ubc_setsize(%llu, %llu) -> %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s extent removal failed ino %llu, size %llu; %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot enter tx size %llu to shrink ino %llu to %llu; %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "ino_shrink_size_prepare",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "ino_prepare_mod",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__clear_purgeability_log"
                },
                {
                    "string": "can_modify_ino(ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "new_size < old_dstream_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(old_dstream_size <= dstream->alloced_size)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "!ino->file_info._writes_in_flight",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s cannot update ino %llu to size %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fsize_valid(prev_fsize)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino->file_info._writes_in_flight == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_io_lock_exclusive_held(apfs, ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fs_get_dstream(apfs, ino)->size <= new_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ino %llu cannot iterate fexts %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "ino_remove_end_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "(new_size % apfs_get_block_size(apfs)) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ino %llu cannot enter transaction %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot dirty ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "(from % sb->fs_bsize) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Cannot decrement %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "rsb_unretain_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "sb->xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(sb->new_sparse_bytes % sb->fs_bsize) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(sb->new_alloced_size % sb->fs_bsize) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sb->new_sparse_bytes <= 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s leaked %llu bytes under ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "(dstream->size <= dstream->alloced_size)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "error != 28",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "tx->tx.xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_truncate_locked",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Warning, file (%llu) exceeds max file size: %lld > %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_get_file_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_get_file_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cannot clone file extents %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %lld alloced size is %lld but size is only %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ino %llu:%llu (orig size %llu:%llu) trimmed %llu extents, %llu blocks (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s BUG BUG BUG: ino %lld unbacked-alloced-size %lld.  capping it to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_trim_file_tail_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: ubc_msync failed on ino %llu (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "do_msync_if_needed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_do_msync_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s cluster_push() failed with %d on ino(%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Invalid state for namedstream inode %p\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s cluster_push() failed with %d on namedstream ino(%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fsync_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Resource fork is an embedded xattr, cannot be written to, returning ENOTSUP\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cluster_pageout on ino %lld (iflags 0x%llx) returned %d for offset %d f_offset %lld, xsize %d filesize %lld a_flags 0x%x (ap->f_offset %lld, size %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s we never called cluster push on ino %lld (%lld:%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_pageout",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s faking zero data for ino %lld (offset %d xsize %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to map the upl! error %d (offset %d size %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s decmpfs_pagein_compressed: ino %lld/%lld pl_offset %lld f_offset %lld size %d file size %lld error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_pagein",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s We have a NULL ino?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Namedstream inode for obj-id %lld is for an embedded xattr, returning EINVAL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"attempt to write block zero on xattr io!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Possible corruption - unwritten extents at offset %lld in dstream %lld on regular volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ### obj-id %lld/%lld err %d offset %lld size %lld mapflags %d dstream %lld/%lld ###\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write data: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"ino %lld: fs_map_file_offset() returned %lld:%lld (%lld) but that does not cover %lld:%lld (map_flags 0x%x; dstream %lld/%lld\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"VNODE_WRITE and VNODE_READ are mutually exclusive\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"roundedRequestSize == 0\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Cannot update ranges when mapping extent %lld:%lld->%lld for %zu bytes at offset %lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s blockmap lut lookup(%lld, %lld) failed, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: blockmap graft(off: %llu, byte len: %lu) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Fusion mapping is already initiated: R:%u W:%u\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_vnop_blockmap",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s Error getting state during contiguous check for strategy: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_check_contiguous",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d searching for recovery extent, buf_blkno 0x%llx, buf_count 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: extent overlap with recovery changed between strategy and blockmap, return EIO, bp_bcount 0x%llx, recovery_bcount 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't map data.",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_recover_data_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"xattr context not set up for getxattr\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s unknown style of xattr (flags 0x%x) on xattr %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to cache ekwk for xattr %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_inode_getxattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "__func__\" doesn't support the resource fork\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: ino %llu, xattr '%s', couldn't look up the fsroot tree, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s IO failed with %d for IO %llu:+%llu to ino %llu, xattr '%s', tmp ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't get dstream from tmp inode %llu, owner %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_lookup() under ino %llu, xattr '%s' failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to enter transaction sized %llu on ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ino %llu, IO %llu:+%llu, xattr '%s': tree insert failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %llu, xattr '%s', removing the old xattr failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update ino %llu, xattr '%s' size %llu failed, err%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %llu, xattr '%s', xattr tmp inode deallocation failed, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: error, %d, when checking tree entry size %u, %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "should_embed_xattr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_setxattr_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs_fsync_internal failed on ino %llu (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_fsync_for_cloning",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fsync_for_cloning",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s could not get dstream for namedstream inode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"private id 0 for ino %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s tree_insert failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_parent_xattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: vnode creation failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot acquire fake vnode usecount %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot allocate tmp ino %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot alloc fake vnode %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "tmp_ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_alloc_tls",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_inodes_",
                "_pfkur_thread_start"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot get fake vnode %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "ier_free_fake_vnode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "apfs->apfs_pfkur.thread_state != pfkur_state_debug",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: pfkur iteration returned error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_roll_all_inodes_continuation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "!\"pfkur iteration returned unexpected \" \"error\"",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to get next pfkur state object, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "pfkur_tree_iterate_pfkursos",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_pfkur_roll_all_inodes_continuation",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: volume unrollable %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot start background thread %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_start",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ier_blockout_enter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_ier_blockout_enter",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot resume background thread %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_resume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkur_debug_enter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_debug_enter",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkur_blockout_enter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_pause_to_allow_snap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkur_stop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_stop",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "stale_pfkurso.current_id == pfkurso->current_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_pfkurso_update_tx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: pfk upgrade request not supported on volume for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "orig_prot_class > 2",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(new_prot_class <= 2) || (kb_supports_class_d && (new_prot_class == 4))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!(ino->internal_flags & INODE_PROT_CLASS_EXPLICIT)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: ino %llu has corrupt rsrcfork dstream cypto id\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "sino->private_id == xdstream.xattr_obj_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: failed to update dstream on namedstream inode %llu for inode %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: failed to update dstream on tmp namedstream inode %llu for inode %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu has no dstreams\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot update pfkurso to id %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot alloc new crypto %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_enqueue_upgrade_prot_class",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: the inode already has explicit prot class set\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_enqueue_upgrade_prot_class_debug",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_enqueue_upgrade_prot_class_debug",
            "prototype": "",
            "backtrace": [
                "_handle_pfku_rolling_op",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot dealloc tmp ino %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_roll_ino_debug",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_roll_ino_debug",
            "prototype": "",
            "backtrace": [
                "_handle_pfku_rolling_op",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to deallocate extent %llu:+%llu, ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to decrement refcount of crypto_id %llu, ino %llu, ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s could not remove fext %llu:+%llu @ %llu, ino %llu, ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to re-reference extent %llu:+%llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to re-increment refcount of crypto_id %llu, ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to re-retain crypto_id %llu, ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to update, ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Failed to deallocate extent %llu:+%llu",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Failed to increment crypto refcount=%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: could not remove fext %llu:+%llu @ %llu, for ino %llu, ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Transaction %lld is closing, pause hole punching on inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Accumulated %lld sparse bytes for inode %lld in transaction %lld, pausing hole punching\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"Zeroing a range of an encrypted file is not implemented\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "__punch_hole_cb",
            "prototype": "",
            "backtrace": [
                "_punch_hole_range_file",
                "_handle_punch_hole",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s file is dataless, and the caller is unprivileged\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s This shouldn't happen: File is compressed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s This shouldn't happen: file is converting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to msync for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot punch unaligned hole: [%llu, %llu); ino %llu, size %llu, alloced_size %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get transaction of size=%llu with error:%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s iteration failed while on %llu:%llu, ino %llu, ret%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Could not insert sparse extent %llu:+%llu for ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to invalidate %llu:%llu for ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_punch_hole_range_file",
            "prototype": "",
            "backtrace": [
                "_handle_punch_hole",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get next jobj in fsroot tree, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "searchfs_iterate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get graft root ino for graft dir %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "searchfs_process_object",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: ino %llu does not have a NAME!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "searchfs_ln_iter_first",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get host fsroot tree, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to initialize host fsroot tree iterator, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to switch iterator to graft, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get iterator next, in_graft %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to switch iterator, in_graft %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_searchfs_iterate",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_searchfs"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume's seal is marked as broken\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Found %d stray compressed inodes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_check_seal",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_io_lock_shared_to_exclusive",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_io_lock_shared_to_exclusive",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s *** ino %lld resuming truncation to pos %lld (from %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to remove the remaining extents on ino %lld (rret %d; num_deleted %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** reset ino %lld size back to %lld (from %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s *** DANGER! ino %lld has prev_fsize %lld but size %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s no name field in ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to vnode_create the vnode for %lld!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: zero devt: old %llu, %d; new %llu, %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_jhash_swap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"jhash_swap: apfs object with a zero devt.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_load_inode_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot allocate memory to hold information about reserved range in inode %lld, releasing reservation for additional %lld bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate memory to hold information about unwritten range in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_drop_rangelist_entries",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "\"Attempt to release %lld bytes for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Only %lld bytes have been reserved for inode %lld, not enough to release %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Byte counter %lld is not block aligned for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Cannot release reservation of %lld bytes for inode %lld: counter is not aligned to block size\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": " on the capacity tier",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to release %llu block reserved for inode %lld%s: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Underflow detected when releasing %lld reserved blocks for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Not enough blocks have been reserved to release %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_drop_reservation",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_record_intention_to_allocate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_verify_rangelist"
                }
            ],
            "symbol": "_apfs_record_intention_to_allocate",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_confirm_intent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_confirm_intent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Namedstream parent's vnode pointer (%p) different than what it is suppossed to be (%p)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_get_nstream_parent_inode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_flush_allocated_unwritten_ranges",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_verify_rangelist"
                }
            ],
            "symbol": "_apfs_flush_allocated_unwritten_ranges",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume is getting unmounted, returning EBUSY\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot flush data - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot flush data for inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to finish all transactions - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_flush_dirty_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unexpected size of extended attribute record for inode %lld: expected %zd, got %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Missing resource fork for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_get_verification_info",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s invalid offset requested for %lld/%lld pl_offset %lld f_offset %lld size %d file size %lld returning EINVAL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not create UPL : ino %lld/%lld pl_offset %lld f_offset %lld size %d file size %lld error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read data for compressed inode %lld/%lld pl_offset %lld f_offset %lld size %d file size %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_pagein_with_verification",
            "prototype": "",
            "backtrace": [
                "_apfs_pagein"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s TAIL-FIXUP: ino %lld (iflags: 0x%llx) has stream %lld:%lld but last extent is %lld:%lld (%lld). inserting hole\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fixup_file_tail",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lookup_file_extent_ext"
                },
                {
                    "string": "%s:%d: %s *** ino %lld does not have an extent for pos %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ino %lld failed to insert tail extent %lld:%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s TAIL-FIXUP 2: ino %lld no extent covering dstream->alloced_size %lld (fsize %lld). truncating to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fixup_file_tail",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld (private-id %lld) has a missing dstream_id (size %lld/%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "check_for_missing_dstream",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_check_for_missing_dstream",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "split update",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_trim_range_update_counters"
                },
                {
                    "string": "trim tail",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_trim_range_update_counters"
                }
            ],
            "symbol": "_apfs_update_ranges_on_allocation",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "trim head",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_trim_range_update_counters"
                }
            ],
            "symbol": "_apfs_trim_ranges_in_region",
            "prototype": "",
            "backtrace": [
                "_apfs_update_ranges_on_allocation",
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Resource fork is an embedded xattr - cannot be written to, returning EIO\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_nstream_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No dstream associated with namedstream inode, EIO\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_tx_enter for %llu blocks failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s get_new_crypto_id returned  error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** failed to set dstream as an extended field of xattr ino %lld (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not allocate enough space, requested %lld, got %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_alloc_and_set_xattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s removing xattr extents under ino %llu, id %llu, failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error decrementing crypto on-disk refcount %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_free_old_xattr",
            "prototype": "",
            "backtrace": [
                "_apfs_setxattr_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "is_mastering_env",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_setxattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s suspicious looking drec entry: file-id %lld, name_len %d name %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "attrlistbulk_iterator",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Mount point, \"%s\", is %lu > %d bytes long; truncating.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_attrlistbulk_iterator",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_getattrlistbulk"
            ]
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_count_freeable_blocks_in_dstream(%llu) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s get_purgeable_dir_gencounts failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "get_ino_extflags",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_pack_vap_common",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "\"xattr changed without updating namedstream vnode\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s namedstream ### obj-id %lld/%lld retval %d filesize %lld offset %lld resid %lld residual io %lld ###\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_nstream_read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_nstream_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Could not get parent inode for namedstream ### obj-id %lld, returning EIO\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_nstream_vnop_setattr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_nstream_vnop_setattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->iflags & JI_CRYPTO_STATE_RETAINED",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ino %llu default_crypto_id %llu not found\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "workaround31868215",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_open",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_nstream_vnop_write",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_nstream_vnop_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_vnop_mmap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__clear_purgeability_log"
                }
            ],
            "symbol": "_apfs_vnop_mmap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"xattr %p changed from embedded but did not update namedstream inode\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s embedded namedstream ino %lld/%lld pl_offset %lld f_offset %lld size %d file size %lld error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_nstream_vnop_pagein",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot allocate %lld bytes to validate data for extent %lld for data stream %lld on volume %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot map buffer for offset %lld of inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_strategy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ignoring write to xattr blk %lld / %lld %lld (blkno %lld / lblkno %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"Volume state is flipping, what is going on?\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s er: enc: strategy: check_contigous: squashing %d into EIO.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: enc: strategy: extent changed between BLOCKMAP and STRATEGY: returning EIO, bcont %llu, b %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: no crypto state while writing to encrypted file system, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er_state_obj_get returned error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: dec: strategy: lookup extent failed: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: dec: strategy: check_contigous: squashing %d into EIO.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: dec: strategy: extent changed between BLOCKMAP and STRATEGY: returning EIO.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_io_common",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkurso->current_id == inum",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_set_failed_to_load_crypto_state",
            "prototype": "",
            "backtrace": [
                "_apfs_io_common"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No data hash record for offset %lld of data stream %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot find data hash record for offset %lld of data stream %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_collect_hash_records",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot find extent for %lld @ %lld for data stream %lld on volume %s - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Extent @ %lld for data stream %lld does not match hashed region %lld @ %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot update APFS Fusion mapping for extent %lld at %lld for data stream %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read %lld bytes from LBA %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found unallocated extent %lld @ %lld for data stream %lld on volume %s inside hashed region %lld @ %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_apfs_slurp_file_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Missing hash record with %lld bytes remaining at offset %lld in inode %lld on volume %s @ %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12OSDictionary12withCapacityEj"
                },
                {
                    "string": "com.apple.apfs.hash_violation.dstream_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc"
                },
                {
                    "string": "com.apple.apfs.hash_violation.dstream_no_hash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc"
                }
            ],
            "symbol": "_apfs_validate_file_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Data hash mismatch for %zd bytes at offset %lld in %sdata stream %lld of inode %lld: expected %s @ %p, got %s @ %p, data %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Data hash mismatch for %zd bytes at offset %lld in %sdata stream %lld of inode %lld: expected %s, got %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_announce_hash_mismatch",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_announce_hash_mismatch",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s buf_map returned error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_iodone",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s gbm_queuue_for_update: gbm_update = NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s gbm_queuue_for_update: er_state_obj = NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_iodone",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid state %d for compressed file (inode %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not get namedstream parent inode (%d), returning EIO\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.private.apfs.allocate_contig",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s Failed to get crypto ID for temp file: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to allocate temp ino: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to allocate requested space: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to start txn to transfer allocated space to ino %llu: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to transfer fext (laddr %llu) to inode %llu (dstream ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot update parent xattr for ino %llu (spino %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot update inode %llu: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to start txn to get crypto ID for ino %llu: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to create dstream for ino %llu: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to increment on-disk crypto state (crypto ID %llu, dstream ID %llu) refcount: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to allocate %llu bytes (%llu bytes allocated) on ino %llu: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "preallocate_tempfile_allocate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to start txn to decrement extra crypto ref (crypto ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to decrement extra crypto ref (crypto ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_allocate",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to clone extents for ino %llu, error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_parent_xattr for ino %llu (spino %llu) failed with error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_preallocate_inline",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_allocate"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Fext would cross APFS_MAXFSIZE (logical_addr %llu, len %llu, alloced_size %llu) - rejecting transfer.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to increment on-disk crypto state (crypto ID %llu, new dstream ID %llu) refcount: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to remove fext (logical_addr %llu, new dstream ID %llu) from temp inode: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to insert fext into real inode (new logical_addr %llu, new stream ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to decrement extra crypto ref (old crypto ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to decrement extra crypto ref (crypto ID %llu, new dstream ID %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_preallocate_transfer_fext",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_allocate"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to %s namedstream %s for ino %lld! - inode removed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "NO_NAME",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s failed to vnode_initialize the namedstream vnode for %lld! (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s alloc_and_set_xattr failed to create a dstream xattr, error is %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set dstream as an extended field of namedstream inode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_initialize_namedstream_vnode",
            "prototype": "",
            "backtrace": [
                "_apfs_get_namedstream_vnode"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!(((ino->mode) & 0170000) == 0040000)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_inode_unrollable",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fake_vnode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino->vp == fake_vnode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "error == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot make progress ino %llu > offset %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: failed to roll ino %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_maybe_roll_ino_",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_maybe_roll_ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot remove pfkurso for inum %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "!apfs->apfs_pfkur.override_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs->apfs_pfkur.override_inode == ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_maybe_roll_ino_",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_inodes_continuation"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to get namedstream for ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkurso->current_id == ino->hdr.obj_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "pfkur_tmp_ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: unexpected fatal error %d, rolling ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_roll_ino",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs->apfs_ier.override_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_check_override_inode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: cannot start background thread, mach err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_thread_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_thread_start",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot alloc tls %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pfkur_roll_all_inodes_",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_roll_all_inodes_",
            "prototype": "",
            "backtrace": [
                "_pfkur_thread_start"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot join: thread already exited\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "!pfkur_thread_self(apfs)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs->apfs_pfkur.thread == ((thread_t) ((void*)0))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "pfkur_thread_join",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "join pfkur thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_pfkur_thread_join",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "vnode_iocount(ino->vp) > 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "roll_range_sanitize(&range)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot roll ino %llu; iflags %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu has no dstream\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: inode %llu bad sizes %llu, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot raw encrypted clonesplit ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot clone extents ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu range selection failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu range [%llu, %llu) exceeds physical eof %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot alloc rolling %llu space for %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot acquire upl for %llu in %llu:+%llu; err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu pagein failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu pageout failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "!(ino->internal_flags & INODE_WAS_CLONED)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: ino %llu became unrollable %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu final swap failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "!pfkur_tmp_ino->vp",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_roll_all_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot make iterator under ino %llu >= %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: no rollable fexts left in %llu >= %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu unrolled fext %llu:+%llu @ %llu (%llu), < %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_ier_pick_range",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "sfext_end(fs_bsize * (0), (&(j_file_extent_t) { .logical_addr = fs_bsize * (0), .len = fs_bsize * (1), .phys_block_num = (123), }), (&(brange_t) { .start = (123), .len = (1), }), fs_bsize) == (fs_bsize * (1))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (1), (&(j_file_extent_t) { .logical_addr = fs_bsize * (1), .len = fs_bsize * (7), .phys_block_num = (101), }), (&(brange_t) { .start = (100), .len = (9), }), fs_bsize) == (fs_bsize * (8))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (5), (&(j_file_extent_t) { .logical_addr = fs_bsize * (1), .len = fs_bsize * (7), .phys_block_num = (101), }), (&(brange_t) { .start = (100), .len = (9), }), fs_bsize) == (fs_bsize * (8))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (3), (&(j_file_extent_t) { .logical_addr = fs_bsize * (3), .len = fs_bsize * (4), .phys_block_num = (100), }), (&(brange_t) { .start = (98), .len = (4), }), fs_bsize) == (fs_bsize * (5))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (4), (&(j_file_extent_t) { .logical_addr = fs_bsize * (3), .len = fs_bsize * (4), .phys_block_num = (100), }), (&(brange_t) { .start = (98), .len = (4), }), fs_bsize) == (fs_bsize * (5))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (0), (&(j_file_extent_t) { .logical_addr = fs_bsize * (0), .len = fs_bsize * (6), .phys_block_num = (100), }), (&(brange_t) { .start = (103), .len = (2), }), fs_bsize) == (fs_bsize * (3))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (1), (&(j_file_extent_t) { .logical_addr = fs_bsize * (0), .len = fs_bsize * (6), .phys_block_num = (100), }), (&(brange_t) { .start = (103), .len = (2), }), fs_bsize) == (fs_bsize * (3))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (3), (&(j_file_extent_t) { .logical_addr = fs_bsize * (0), .len = fs_bsize * (7), .phys_block_num = (10), }), (&(brange_t) { .start = (13), .len = (2), }), fs_bsize) == (fs_bsize * (5))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (8), (&(j_file_extent_t) { .logical_addr = fs_bsize * (3), .len = fs_bsize * (8), .phys_block_num = (123), }), (&(brange_t) { .start = (131), .len = (5), }), fs_bsize) == (fs_bsize * (11))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (8), (&(j_file_extent_t) { .logical_addr = fs_bsize * (3), .len = fs_bsize * (8), .phys_block_num = (123), }), (&(brange_t) { .start = (127), .len = (6), }), fs_bsize) == (fs_bsize * (11))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (8), (&(j_file_extent_t) { .logical_addr = fs_bsize * (3), .len = fs_bsize * (8), .phys_block_num = (123), }), (&(brange_t) { .start = (127), .len = (3), }), fs_bsize) == (fs_bsize * (10))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (4), (&(j_file_extent_t) { .logical_addr = fs_bsize * (1), .len = fs_bsize * (7), .phys_block_num = (1000), }), (&(brange_t) { .start = (1004), .len = (5), }), fs_bsize) == (fs_bsize * (5))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sfext_end(fs_bsize * (7), (&(j_file_extent_t) { .logical_addr = fs_bsize * (1), .len = fs_bsize * (7), .phys_block_num = (1000), }), (&(brange_t) { .start = (1006), .len = (7), }), fs_bsize) == (fs_bsize * (8))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_make_sfext_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "cur_pbn",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(fext->phys_block_num <= pbn) && (pbn <= fext_pend(fext, fs_bsize))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext->phys_block_num",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_sfext_end",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot lookup <= %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot lookup > %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "error != EINVAL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_dedupe_map_lookup_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "off_in_fext(it->off, &fext)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext.phys_block_num",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "brange_intersects(&remaining_blocks, &mapping_blocks)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_assert_sfext_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "lrange_sanitize(&(lrange_t) {.start = start, .len = len})",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!(start % fs_bsize)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!(len % fs_bsize)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_insert_sparse_fext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!\"cannot roll non-content protected volume\"",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_fext_rollable",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!it->mapping_valid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_sfext_iterator_next",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fext.f.phys_block_num",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "off <= range->r.len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot update tmp ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "ier_alloc_shared_space",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot ref %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot insert fext id %llu, %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "\"cannot get mapping's ek %llu, %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"dedupe mapping uses inode's key\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "block_in_dedupe(pbn, mapping)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_roll_shared_data",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ier_free_tmp_space_",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_unretain_crypto_states"
                },
                {
                    "string": "%s:%d: truncate tmp ino %llu to 0 failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_ier_free_tmp_space_",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "in.start == exp.start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "in.len == exp.len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_round_range_self_test",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "psize > new_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(range->start % (unsigned long long)(1 << PAGE_SHIFT_CONST)) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(range->start + range->len) <= psize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_round_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: can't enter transaction for %llu records, %llu blocks, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot allocate %llu bytes under %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ier space allocation failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot update new space to tmp ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "dstream->size == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "dstream->alloced_size == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_alloc_tmp_space",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "range->start <= 9223372036854775807LL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "range->len <= 2147483647",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(range->start % (range_->is_shared ? apfs_get_block_size(apfs) : (unsigned long long)(1 << PAGE_SHIFT_CONST))) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "upl->len >= range->len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "upl->pl",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_upl_acq",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "num_pages",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ier_pagein_all",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "i <= num_pages",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(f_end - f_start) <= 4294967295U",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: couldn't pagein ino %llu %llu:+%u, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_ier_pagein_all",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "upl->offset <= f_off",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(f_off + len) <= (upl->offset + upl->len)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "f_off < fsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(len % (unsigned long long)(1 << PAGE_SHIFT_CONST)) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(upl->offset % (unsigned long long)(1 << PAGE_SHIFT_CONST)) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "len <= 2147483647",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "f_off < 9223372036854775807LL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fsize <= 9223372036854775807LL",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(f_off - upl->offset) <= 4294967295U",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_cluster_assert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: ino %llu, tmp inode %llu iterator failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: ino %llu, tmp inode %llu dequeue failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "n_fexts && (n_fexts <= (max_fexts - from))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_lend(&fexts[n_fexts-1]) > f_off",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "off_in_fext(f_off, &fexts[0])",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: couldn't pageout %llu:+%u, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "from <= max_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, bsize, 123) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, bsize, bsize) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, (1 << PAGE_SHIFT_CONST), 1+(1 << PAGE_SHIFT_CONST)) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, (1 << PAGE_SHIFT_CONST), 2*(1 << PAGE_SHIFT_CONST)) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, (1 << PAGE_SHIFT_CONST), (1 << PAGE_SHIFT_CONST)) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, bsize+(1 << PAGE_SHIFT_CONST), 1+(1 << PAGE_SHIFT_CONST)) == 2",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, 2*(1 << PAGE_SHIFT_CONST), bsize) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(0, (1 << PAGE_SHIFT_CONST), 64llu*1024*1024*1024*1024) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages((1 << PAGE_SHIFT_CONST), (1 << PAGE_SHIFT_CONST), 2*(1 << PAGE_SHIFT_CONST)) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages((1 << PAGE_SHIFT_CONST), 2*(1 << PAGE_SHIFT_CONST), 1+(1 << PAGE_SHIFT_CONST)) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "count_pages(178257920, 2093056, 1073741824) == 127",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 1, 16384) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 2, 16384) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fexts[0].crypto_id == 0xbb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 4, 2*16384) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 4, 16384) == 3",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fexts[1].crypto_id == 0xcc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fexts[2].crypto_id == 0xdd",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 4, 4*16384) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 4, 16384) == 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fexts[0].crypto_id == 0xdd",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fext_slide(fexts, 4, 65536) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "last == fexts[i].logical_addr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!apfs->apfs_pfkur.override_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!apfs->apfs_pfkur.override_num_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs->apfs_pfkur.override_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs->apfs_pfkur.override_num_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_pageout_all2",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fsize && (fsize <= ((1ULL << ((56 - 1))) - 1))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "len && (len <= 2147483647)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(start % (unsigned long long)(1 << PAGE_SHIFT_CONST)) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "start < fsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "n_pages && (n_pages <= 4294967295U) && ((n_pages * (unsigned long long)(1 << PAGE_SHIFT_CONST)) <= 4294967295U)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_count_pages",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "f_off",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fext_slide",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: Cannot make iterator %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot make sink iterator %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: Cannot enter tx %llu 0 ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "(get_vol_crypto(apfs) == VOL_PFKEY) ? !sb.retained : 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot remove src fext %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: tmp fext too long %llu:+%llu > %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: Cannot move in extent %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: extent movement ino %llu moved %llu bytes; error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: Leaked %llu bytes under ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: Cannot update ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "error ? 1 : (len == sb.bytes_moved)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sb.bytes_moved <= len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: src %llu:+%llu preceeds sink %llu:+%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "\"failed %d: \"\"fext_iterator_next(snk_iter)\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src->logical_addr < snk.logical_addr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "new_end > src->logical_addr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src->logical_addr == snk->logical_addr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "insert_over",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "snk->logical_addr < src->logical_addr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src->logical_addr < fext_lend(snk)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "head_split",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "tail_split",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_ier_swap_in_space",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Cannot increment %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "isb_retain_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_isb_retain_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Cannot decrement %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "isb_unretain_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_isb_unretain_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "src->start && snk->start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src->len == snk->len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!brange_intersects(src, snk)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot make pext iterator in [%llu, %llu), %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "(snk->start <= pext.hdr.obj_id) && (pext_end(&pext) <= brange_end(snk))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot lookup mapping for %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot %s mapping %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "deref",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot lookup pext <= %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "pext_iterator_next",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_isb_blocks_moved",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pext->len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pext_clamp",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!pext_iterator_poisoned(it)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "pext_end(&it->cur) <= it->end_pbn",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_assert_pext_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "len && ((len % (1 << PAGE_SHIFT_CONST)) == 0)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "upl->len >= off",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_upl_rel",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!(ier_tmp_ino->iflags & JI_CRYPTO_STATE_RETAINED)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_free_tmp_space",
            "prototype": "",
            "backtrace": [
                "_pfkur_roll_all_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot reupdate ino %llu for new id, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "tmp_error != 28",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino->default_protection_class > 2",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "xdstream",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sino->default_protection_class > 2",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "has_datafork || has_resourcefork",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "new_id != 4",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "new_sid != 4",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: failed to update dstream on xdstream %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "%s:%d: cannot update rsrcfork xattr for ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_new_def_crypto_tx",
            "prototype": "",
            "backtrace": [
                "_pfkur_enqueue_upgrade_prot_class"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!\"ier didn't find override extent\"",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!\"pfkur didn't find override extent\"",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ier_check_override_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs->apfs_pfkur.override_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_check_override_inode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkurso->version == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "pfkurso->current_offset <= ((1ULL << ((56 - 1))) - 1)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_pfkur_pfkurso_assert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "pfkur-thread-yield",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_pfkur_continue_locked"
                }
            ],
            "symbol": "_pfkur_yield",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot update ino %llu to unset flag; err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_pfkur_pfkurso_remove_done",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Cannot read outside of the given extent: ino %llu, addr %llu not in extent %llu:+%llu @ %llu\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"real_fext.len(%llu) != num_bytes(%u)\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_jdev_kext_io_",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s missing graft state for ino %llu, iflags 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Graft lookup failed to get root vp: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"cache_lookup returned -1 but did not return vnode\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ### Found directory entry but could not get inode even after retry for dvp %p and %s, returning ENOENT",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Found directory entry but could not get inode 1024 times for dvp %p and %s\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Found directory entry but inode %p has has iflags 0x%llx 1024 times for dvp %p and %s\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_vnop_lookup",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s inode returned from vnode_getfirmlink has JI_DELETED set iflags: %llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"inode returned from vnode_getfirmlink has JI_DELETED set iflags: %llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"apfs_get_firmlink_target_vnode failed with error %d, volume %s, device %s\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Updating stitched firmlinks failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vnode_setasfirmlink failed with error %d, volume %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_firmlink_target",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"error is 0 but drec is NULL\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_internal_lookup_with_case",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: can't set prot-class-dir-none on non-dir item %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "setup_prot_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s rejecting class open (class %u) because we're not content protected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_is_valid_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_setup_prot_class",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to update doc-id %d for inode %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove doc-id for inode %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_inherit_doc_tombstone",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to create symlink named %s in dir w/obj-id %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create symlink xattr (err %d) on ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_symlink",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs: read: danger! read on a dead inode (%llu)!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ### obj-id %lld/%lld retval %d filesize %lld offset %lld resid %lld residual io %lld ###\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_trim_reservation_tail",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_verify_rangelist"
                }
            ],
            "symbol": "_apfs_trim_reservation_tail",
            "prototype": "",
            "backtrace": [
                "_prepare_write_and_lock",
                "_apfs_vnop_write"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld has no name! (should be: %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove ino %lld drec name: <%s> (len: %d) name: <%s> name_len %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalidating reserved ranges after deletion of ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_vnop_remove",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s rmdir on snapshot vnode, returning EPERM\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_rmdir_with_flags",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Reserved unwritten range %lld:%lld,%d for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "release_all_reserved",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_decrement_unwritten_ranges_counters"
                }
            ],
            "symbol": "_apfs_release_all_reserved_space",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "release",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Underflow detected in reserved ranges counter when trying to release reserved blocks for inode %lld: have %d ranges, need %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_release_reserved_blocks",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_release_reserved_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "wait-for-busy-from-parent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "wait-for-busy-to-parent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s how odd... there is no drec for ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *#*#*#* from_ino %lld has nlink %d but no sibling link on the drec %lld:%s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s seclude rename: failed to clone %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s *** to ino %lld has nlink %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to move ino %lld to purgatory from dir %lld : %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s !!! failed to fixup to_ino %lld (to_drec ino %lld name %s; to_ino parent/name %lld/%s nlink %d; iret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update ino %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove the TO sibling hard link from ino %lld sib-id %lld (nlink %d) for drec %lld/%s err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove the FROM sibling hard link (ino %lld, sib-id %lld, nlink %d) and drec %lld/%s (err %d) (to_ino %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert updated to_drec %lld:%s ino %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to RE-insert orig from_drec %lld:%s ino %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** failed to remove the from drec for ino %lld to_ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_renamex",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_rename"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_vnop_readdir",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_readdir",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: suspicious looking drec entry: file-id %lld, flags 0x%x name_len %d name %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: suspcious delen of zero for drec w/file-id %lld flags 0x%x name_len %d name: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_make_dirent_iterator",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_readdir"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "could not materialize ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_apfs_vnop_clonefile",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s src ino %lld is in sync root id %lld. asking for materialization\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s materialization of src ino %lld failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to clone %s to %s (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_clone_internal",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_clonefile"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_vnop_getnamedstream",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_vnop_getnamedstream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_vnop_makenamedstream",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_vnop_makenamedstream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "(((from_inode->mode) & 0170000) == 0100000) && (((to_inode->mode) & 0170000) == 0100000)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "vfs_fsprivate(vnode_mount(from_inode->vp)) == vfs_fsprivate(vnode_mount(to_inode->vp))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "from_inode != to_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s cannot move extents: rolling is active, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to load pfk upgrade rolling state object for destination inode %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update pfk upgrade rolling state object for destination inode %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vnop_exchange",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"apfs_vnop_verify with split verification context is used on inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Verification context does not match the inode %lld: expected hashes for data stream %lld, got %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Verification context does not match the offset in inode %lld: expected %lld, got %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Verification context for inode %lld is empty\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"apfs_vnop_verify for ino %p failed for volume %s @ %s, error %s (%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_vnop_verify",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "get_uncompressed_size_for_verify",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_uncompressed_size_for_verify",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_verify"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s attempting to zero %lld bytes at offset %lld in data stream %lld of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_verify_uncompressed_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%ss%d Missing hash record with %zd bytes remaining at offset %lld in data stream %lld of inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12OSDictionary12withCapacityEj"
                },
                {
                    "string": "com.apple.apfs.hash_violation.compressed_dstream_no_hash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc"
                }
            ],
            "symbol": "_apfs_verify_uncompressed_data",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_verify"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_vnop_setattr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid class value %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "mcp_chclass",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "rsrcfork->default_protection_class == ino->default_protection_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: ino %llu unknown class %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "mcp_chclass_file_locked",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "mcp_chclass_promotes(apfs, ino_get_class_or_none(apfs, ino), new_class)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"%s:%u: \" \"empty file %llu enqueued\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino_get_class_or_none(apfs, ino) == ino_class_v",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "mcp_chclass_promote2",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to change data protection class %d on file %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "(new_class != ino_class_v) && (new_class != ino_class_none)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s could not get the real inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can not set dataprotect class %d on file %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to clone extents for ino %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "pre-change-prot-class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_unretain_crypto_states"
                },
                {
                    "string": "%s:%d: %s changing protection class from %d to %d failed (%d) on ino %lld.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "cleanup-change-prot-class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_unretain_crypto_states"
                },
                {
                    "string": "reload-change-prot-class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_retain_crypto_states"
                },
                {
                    "string": "!fs_is_content_protected(apfs)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_vnop_setattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"%s:%u: \" \"file %lld is enqueued for upgrade of data protection \" \"class but its state object is missing\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_mcp_chclass_promoting",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cluster_push_err failed on ino %llu (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "remove_stale_dir_iterators",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_vnop_inactive",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"we should never reclaim the xattr io vnode unless we are unmounting! (apfs %p, xattr_io_vnode %p)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s passed a vnode with a NULL fs ptr! (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s free'ing %d iterators\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Allocated unwritten range %llu:%llu still exists before fsize (%llu) / prev_fsize (%lld) on ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "ramrod",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                },
                {
                    "string": "deleted",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                },
                {
                    "string": "restored",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                },
                {
                    "string": "%s:%d: %s failed to delete inode #%d ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Releasing space reserved for inode %lld (dstream %lld/%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get transaction to update dirty inode, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update inode %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "ino->jhash_flags & JH_BUSY",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "reclaim",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_unretain_crypto_states"
                }
            ],
            "symbol": "_apfs_vnop_reclaim",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": ".sqlite",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strstr"
                },
                {
                    "string": " Index",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strstr"
                }
            ],
            "symbol": "_is_sqlite_db_file",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_reclaim"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Hash chunk at offset %lld in data stream %lld is enormous - it needs %lld bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Hash mismatch for %lld bytes at offset %lld in data stream %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot magic up vnode for inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate memory to verify compressed data in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Inode %lld has compressed flag but is not compressed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to find dstream for inode %lld (dstream id: %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unexpected data size for extended attribute %s of %lld: expected %zd, got %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot create UIO for offset %lld of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot get data at offset %lld of compressed inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read enough data to fill buffer of %lld bytes from offset %lld of inode %lld - %zd bytes short, file size is %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_validate_file_data",
            "prototype": "",
            "backtrace": [
                "_apfs_check_seal",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!raw_ino_split(raw_ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ubc_msync failed on ino %llu (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cluster_push_err failed on namedstream ino %llu (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_parent_xattr failed on namedstream ino %llu (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot copy list of unwritten extents from inode %llu: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "rawenc-",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_apfs_raw_encrypted_lookup",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->private_id == raw_ino->private_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "raw_ino_split(raw_ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_raw_encrypted_clone",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_raw_encrypted_clone",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"you can't have apfs %p w/devt %d mismatched w/ino %lld %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "entry->jhash_flags & JH_BUSY",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "raw jhash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_apfs_raw_inode_get",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "(entry->hdr.type == APFS_TYPE_INODE) && ino_is_raw(entry) && !raw_ino_split(entry) && entry->file_info._unraw_obj_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_assert_raw_entry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino_is_raw(ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_raw_ino_split",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "((dest_ranges)->tqh_first == ((void*)0))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_copy_list_of_unwritten_ranges",
            "prototype": "",
            "backtrace": [
                "_apfs_raw_encrypted_lookup"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Skipping metazone_init() as backing store is sparse\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s no metazone for device %d, of size %llu bytes, block_size %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s metazone for device %d of size %llu blocks (encrypted: %lld-%lld unencrypted: %lld-%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s metazone also includes omap zone (%lld-%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to upgrade spaceman from version 0 to 1: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s failed to initialize data zone for allocations of size %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Initialize soft block-out range %d %d %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to initialize allocation zone for allocations of %llu blocks from disk: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Persistent allocation zone at slot %llu has invalid current boundaries\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "spaceman_sanitize_datazone",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary index\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s Clearing persistent allocation zone at slot %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s refusing to upgrade spaceman! new_smp_size %u old_smp_size %u block_size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_allocation_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tried to get metazone alloc index for unknown type: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't allocate metadata block(s) nx->nx_allocations_not_yet_updated_on_host %lld raw free space %llu (desired_count %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Bogus attempt to perform metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Bogus attempt to perform non-metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to search bitmap hints: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s skip bad chunk info ci @ block %lld (cib %lld) ci_index 0x%x ci_addr 0x%llx (expect 0x%llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update chunk for alloc zone %llu: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to move roving pointer for dev %d error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found enough data to allocate outside the soft block-out range, re-enable soft block-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Space outside soft block-out range seems fragmented (requested %llu, but could alloc only %llu), disable soft block-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_alloc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to update allocation zone boundaries: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_initialize_allocation_zone_from_disk",
            "prototype": "",
            "backtrace": [
                "_spaceman_allocation_init"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to assign chunk %llu to allocation zone %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_evaluate_chunk_for_disabled_allocation_zones",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s error getting cab %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error getting cib %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update allocate zone %llu: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_get_new_chunk_for_allocation_zone",
            "prototype": "",
            "backtrace": [
                "_spaceman_alloc"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s found mapping tree with old subtype\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_get_evict_mapping_tree",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_get_evict_mapping_tree",
            "prototype": "",
            "backtrace": [
                "_nx_unblock_physical_range"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get spaceman oid %lld for checkpoint %s traverse: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman checkpoint %s traverse failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get omap for checkpoint %s traverse: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap checkpoint %s traverse failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get reaper for checkpoint %s traverse: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx reaper checkpoint %s traverse failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Fusion WBC checkpoint %s traverse failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get fs[%d] oid %lld for checkpoint %s traverse: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs[%d] checkpoint %s traverse failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get test object 0x%llx of type 0x%x/0x%x for checkpoint %s traverse: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to checkpoint %s traverse test object 0x%llx of type 0x%x/0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get reap list object oid %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Invalid reap list entry nrl_entries[%d].nrle_next = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s WBC checkpoint op %u returned %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_checkpoint_traverse",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s IP free queue tree is too large: %lld nodes (limit %d) xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s main free queue tree is too large: %lld nodes (limit %d) xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tier2 free queue tree is too large: %lld nodes (limit %d) xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_checkpoint_traverse",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to get object 0x%llx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_reaper_obj_get",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get reap list tail: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_reaper_add",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s invalid reap_id (%llu), must be smaller than nr_next_reap_id (%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_reaper_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_reaper_wait",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_metadata_range_add",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_metadata_range_add",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tx_leave failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_unblock_physical_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_get_inodes_size failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Update only for fs %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s No dstreams to promote\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Container is fused, This API is for use only on non-fusion HDD setups\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Init soft block-out range to %lld, %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Soft block-out range already initialized to %lld, %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s range overlapps nx metadata, increasing range by %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s block-out range %lld, %lld, to make space for bootcache files\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Free blocks in evicted range %lld,%lld is %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_spaceman_unset_block_out_range failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Free blocks in evicted range (%lld) smaller than blocks needed for boot files (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Verify all boot files are in the sub-range that was evicted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_verify_bootcache_defrag failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_defrag_hdd_boot_files failed with error %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream_calc_trapped_blocks_in_soft_blockout_range failed for dstream %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_calc_bootcache_blocks_in_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot defrag a volume that's been reverted to snapshot but not mounted rw yet\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to allocate memory for dstreams info\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s A previous call to defrag of the same volume with different xid (%llu != %llu) has been done\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to allocate memory for dstreams\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s inode %lld invalid mode %x or private_id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_defrag_hdd_boot_files",
            "prototype": "",
            "backtrace": [
                "_handle_bc_optimize_inodes",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s block out range is active - cannot determine minimal size at this time",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tier %d, tier_size %lld, sm max_allowed_shrink %lld (i.e. minimal_size %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s volume has %llu snapshots - finding tidemark of all snapshots\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to find tidemark, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snapshot %d: tidemark %llu in on SSD, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s snapshot %d: tidemark %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s tree_iterator_init() for snapmeta, error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs %d, snap_tidemark %lld, max_tidemark %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s the maximal valid filesystem index in the nx_fs_oid array: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error calculating metadata params for block count %lld+%lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s orig_metadata_size %lld, new_metadata_size %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s minimal_size taking into account 2x metadata (old+new) %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s minimal_size after roundup %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s minimal size after taking number of filesystems into account: %llu \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s minimal_size truncated to tier size, %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_get_minimal_tier_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_global_extent_manipulation_lock(%d, %x), (%d, %x, %d, %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_global_extent_manipulation_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to take global_extent_manipulation lock after %d tries",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_is_encryption_rolling failed with error: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_global_extent_manipulation_lock(%d, %x) need to cancel cancellable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_global_extent_manipulation_wait_for_cancellable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s nx_global_extent_manipulation_lock(%d, %x) cancellable has been cancelled, retrying\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_global_extent_manipulation_wait_for_quick",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Exclusive global_extent_manipulation lock taken after %d unsuccessful attempts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Shared global_extent_manipulation lock taken after %d attempts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_global_extent_manipulation_lock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_global_extent_manipulation_unlock(%d, %x), (%d, %x, %d, %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_global_extent_manipulation_unlock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s num_shared underflow\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s num_quick underflow\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s lock is not exclusive\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_global_extent_manipulation_unlock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_ongoing_sync_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_nx_register_fs_mount_unmount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_num_ongoing_mounts underflow\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_unregister_fs_mount_unmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_unregister_fs_mount_unmount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Lock is not cancellable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Cancel block out operation already in progress, join current\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_global_extent_manipulation_wait_for_block_out_cancel",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Block out is now cancelled\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_cancel_block_out",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_get_block_count_per_dev",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_get_block_count_per_dev",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s There is no volume with index %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get volume %d, error %d(%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_get_volume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not find a volume with specified role (%d) in the input volumes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_get_role_volume_uuid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_volume_group_manual_update",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_manual_update",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid number of volumes %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_volume_group_add",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient29methodContainerVolumeGroupAddEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not find any volume in volume_group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Some volumes in volume group %s, are still mounted cannot delete\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_replace_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid volume index %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume %d does not exist\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get volume %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient29methodContainerVolumeGroupGetEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: Could not find volumes in group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_volume_group_get_volume_indices",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_get_volume_indices",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to determine if volume is origin, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Destitch all firmlinks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Destitch inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_get_firmlink_target_vnode_internal failed to find target vnode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_volume_group_destitch_firmlinks",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_unmount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume %s role %x Not a System or data volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Volume %s is not in a volume group\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to allocate memory for volume group\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Set volume (role 0x%x) to %llx xid %llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s inode %lld already in stitched list\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to allocate memory for firmlink\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_insert failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_update",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_volume_groups_destroy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "Fusion WBC Elevator",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_thread_shutdown"
                },
                {
                    "string": "wbc-elevator-finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_thread_shutdown"
                },
                {
                    "string": "Fusion IO Flusher",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_thread_shutdown"
                },
                {
                    "string": "inflight-flusher-finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_thread_shutdown"
                },
                {
                    "string": "\"Unmounting in progress on %p, started by %p\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "nx_mount.c",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s waiting for transaction to finish\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tx_finish"
                },
                {
                    "string": "tx_unmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tx_finish"
                },
                {
                    "string": "%s:%d: %s First sync/barrier failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Final sync/barrier failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_unmount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_reaper_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_nx_reaper_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_reap_list_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_nx_reap_list_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: reaper thread is exiting, returning EBUSY\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s object type 0x%x not reapable?: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get object 0x%llx of type 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error reaping object 0x%llx of type 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_reaper_next_record",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_reaper_thread",
            "prototype": "",
            "backtrace": [
                "_nx_reaper_wakeup"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Requested zero length blocked-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Requested block-out range start %lld is outside %s device size (size=%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Requested block-out range [%lld,%lld] is outside %s device size (size=%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Continue eviction (possibly after power fail) %lld+%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s NX already has a blocked-out range [%lld,%lld]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_check_snapshots_data_location failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_resize: calling fusion_wbc_force_flush_extent for range %lld+%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_block_out_wbc_force_flush_extent failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_leave after eviction of nx omap mappings failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Evicting nx keybag.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_keybag_evict failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s (oid %lld) has incompatible features: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Evicting apfs keybag.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs_keybag_evict failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_leave after eviction of omap mappings of fs %d failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Releasing apfs tree objects for fs index %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_reaper_wait for mapping tree failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_finish failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Blocked out range is not free after eviction\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s block out range eviction succeeded!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_block_out_physical_range failed with ENOSPC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s nx_block_out_physical_range failed with error %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman_set_block_out_range failed with ENOSPC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s spaceman_set_block_out_range failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_block_out_physical_range_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s fs %llu has %llu snapshots - verifying no snapshot data is in blocked-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s snap_meta %lld is dataless\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found extent %lld÷%lld overlapping blocked-out range %lld÷%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get next pext for snapshot %lld, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_check_snapshots_data_location",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_block_out_wbc_flusher_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_nx_block_out_wbc_force_flush_extent",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tx_leave after eviction of nx omap failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_evict_omap_tree",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s unexpected tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snap_meta %lld is dataless, evict SB only\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s volume is not sealed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s volume does not support pfkur\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s snapshot is not sealed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Fext tree not physical\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Couldn't get snapshot fext tree, oid %lld, sblock_oid %lld, name '%s', err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s pfkur tree not physical\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Couldn't get snapshot pfkur tree, oid %lld, sblock_oid %lld, name '%s', err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_evict_physical_tree_in_snap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Range %lld:%lld is allocated after eviction!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to alloc buff for phys object\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error reading block %lld: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Object %lld of type %x, subtype: %x is not free\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Searching for phys_ext at addr %lld, len %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s   Found phys_ext type %d at addr %lld, len %lld, owner %lld, refcnt %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s     jobj owning phys_ext is an inode: vp 0x%llx, parent %lld, iflags 0x%llx, internal_flags 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s     could not locate owning file_ext for physical extent with id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s     owning file_ext: id %lld, logical_addr %lld, len %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s     xattr for that extent: name '%s', obj_id %lld, ino_obj_id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s       inode owning xattr: id %lld, vp 0x%llx, parent %lld, iflags 0x%llx, internal_flags 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s       failed to find the inode owning that xattr\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s     failed to find an xattr fow which that extent belongs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman_is_allocated(%lld) call failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get spaceman structure: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_is_allocated",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_debug_unfree_blocked_out_range",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "collect_snapshot_sbs_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_collect_snapshot_sbs_callback",
            "prototype": "",
            "backtrace": [
                "_nx_debug_unfree_blocked_out_range",
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to allocate memory for dstream_nx_info array\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Not enough free space left to promote dstream %lld, free space %lld, blocks left to promote %lld, fs %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to promote dstream %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Promoted %lld blocks of %d dstreams (out of %d) to soft block-out range. %d dstreams too large, %d dstreams lost\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_promote_to_soft_block_out_range",
            "prototype": "",
            "backtrace": [
                "_nx_defrag_hdd_boot_files",
                "_handle_bc_optimize_inodes",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s Verifying %d boot files are in the soft block-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fs_verify_bootcache_defrag failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream_verify_in_range failed for dstream %lld, inode %lld, failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_verify_bootcache_defrag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_verify_bootcache_defrag",
            "prototype": "",
            "backtrace": [
                "_nx_defrag_hdd_boot_files",
                "_handle_bc_optimize_inodes",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: NULL context pointer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Invalid parameters faddr %p flen %p bt %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get first extent in the free extents tree, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_find_free_blocks_callback",
            "prototype": "",
            "backtrace": [
                "__ZN19AppleAPFSUserClient21methodResizeContainerEPS_PvP25IOExternalMethodArguments"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to find extent equal or larger than %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to find extent less than %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_get_next_free_blocks_from_free_extents_tree",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error allocating the ranges in the extents tree for new %s: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error allocating %lld blocks @ %lld for new %s: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s new %s area (%lld blocks) moved from %lld to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s new %s (%lld blocks) moved from %lld to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s error allocating %lld blocks @ %lld for metadata: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s metadata range (%lld blocks) moved from %lld to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get next extent in fragmented metadata tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_resize_mark_metadata_allocated",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error storing metadata tree for %s: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_resize_store_fragmented_metadata",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_resize_store_fragmented_metadata",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume %d is not in volume group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Multiple input volumes with role 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume is already in a volume_group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume %d is crypto rolling, can't add to group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume %d has a pre-existing unlock records, can't add to group %s \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_modify for volume %d failed with error %d(%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Changed vol %d from volume_group %s to volume id %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Assigned vol %d to volume_group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Missing required roles in volume group: %s %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_get for fs oid %llx, failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                },
                {
                    "string": "%s:%d: %s tx_leave failed with error %d(%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_set",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s not enough space for all volumes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_volume_group_get_volumes_with_ctx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s, root hash authentication %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "is_root_hash_authentication_required",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "is required",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "will be skipped",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "Release",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %s kext with internal build: %d, ARV disabled: %d, booting xid: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "is_root_hash_authentication_required_osx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s root hash validation is required as the boot-arg is set\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s strict graft, root hash authentication failure is required\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s root to xid set, root hash authentication will be skipped\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s internal OS build with root to xid set, root hash authentication will be skipped\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_is_root_hash_authentication_required",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s volume seal is broken\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"%p: volume seal is broken\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s could not authenticate personalized root hash, skipping verification\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"could not authenticate personalized root hash! (%d),  (%p, %zu)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s validate_on_disk_root_hash failed with error: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"could not validate root hash %s (%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"APFSX: could not validate root hash %s (%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s successfully validated on-disk root hash\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get integrity meta object, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s root_hash size mismatch, expected %zu but got %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid root_hash header - payload version <%ud> != on-disk version <%ud>\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid root_hash header - payload hash type <%ud> != on-disk hash type <%ud>\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid root_hash header - payload hash size <%ud> != on-disk hash size <%ud>\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s root_hash mismatch, expected %s but got %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authenticate_root_hash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "crypto_hash_cleaner",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_thread_set_thread_name"
                },
                {
                    "string": "%s:%d: %s Could not start crypto_hash_cleaner thread: ret=%d apfs_flags=%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "crypto_hash_cleaner_wakeup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Crypto cache (type %u) size hit the hard limit (%u)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_crypto_obj_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No entry for root dir!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FAILED TO LOAD THE ROOT INODE!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to vnode_create the root vnode!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to jhash_insert the root inode (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s No entry for private metadata dir!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FAILED TO LOAD THE PRIVATE DIR INODE!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create the system vnode for the private dir (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create the system vnode for the snapshot dir (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_setup_snapvnodes failed (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot create alternate single xattr vnode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create the system vnode for xattr I/O\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s no name field in ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to vnode_create the vnode for .snaps! (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "create_snap_dir_vnode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_load_fs_vnodes",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: failed to flush data for inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_sync_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_sync_callback",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "purgatory_cleaner",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_thread_set_thread_name"
                },
                {
                    "string": "apfs_cleanup_purgatory_wrapper",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_cleanup_purgatory_wrapper",
            "prototype": "",
            "backtrace": [
                "_purgatory_cleaner_wakeup"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "mounting",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_log_mount_unmount",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.rootless.internal-installer-equivalent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_apfs_allow_root_update",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Failed to extract root-hash for BS dmg from /chosen - error %s(%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"BASESYSTEM IS NOT SEALED!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_handle_basesystem_rootmount",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to retrieve default root snapshot xid: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_find_named_root_snapshot_xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to find root-snapshot-name <%s>: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to allocate memory for root-snapshot-name",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s The global payload bytes pointer is NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_find_named_root_snapshot_xid",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Tagged and root-snapshot-name are the same.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s failed to load the integrity meta object: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s RELEASE build rooting from tagged sealed snapshot!",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Rooting from tagged snapshot, xid %llu. Integrity checks will be %s.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "disabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "enabled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Rooting from tagged snapshot, xid %llu.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_apfs_root_snapshot_select",
            "prototype": "",
            "backtrace": [
                "_apfs_vfsop_mount",
                "_apfs_vfsop_mountroot",
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s vnode_ref failed with on snap_vp for %llx failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s mounting snapshot w/snap_xid %lld and sblock oid 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s fs_lookup_snapshot_metadata_ext %llx failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not locate super block w/sblock_oid 0x%llx for snapshot w/xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s flags indicate volume is mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snapshot can't be mounted on a locked volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create virtual device for snap\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to fetch the integrity object for snap 0x%llx - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Validating the root hash for authenticated snapshot mount ...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_snapshot_mount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to enter transaction for implicit revert\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_incompatible_bit_mismatch",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Set implicit revert to snapshot \"%s\" w/snap xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_incompatible_bit_mismatch",
            "prototype": "",
            "backtrace": [
                "_handle_snapshot_mount"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s authentication is allowed only on readonly mounts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Validating the root hash for authenticated mount ...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ignoring root hash mismatch\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to allocate memory for mount of %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s mount of %s specified content-protection but volume does not support it.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vol-uuid: %s block size: %d block count: %lld (%s; flags: 0x%llx; features: %llx.%llx.%llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s failed to load fs private vnodes (err %d) for dev %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ROSV: apfs mounted RO and is the system volume of a volume group and mounted as the root fs: creating the shadow fs_root\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ROSV: failed to set up shadow fs_root: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_volume_group_update device %s failed with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "/System/Volumes/Data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "/System/Volumes/VM",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "%s:%d: %s volume with role %u will be mounted until system shutdown\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_should_be_system_mount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "/System/Volumes/iSCPreboot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "/System/Volumes/Hardware",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "/System/Volumes/xarts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strcmp"
                },
                {
                    "string": "%s:%d: %s unexpected volume role %d, not on iSC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_is_on_designated_isc_mount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_mount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tx_finish() failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "mount_failure_cleanup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_mount_failure_cleanup",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s@snap-%lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_apfs_vfs_getattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: mount update in progress.  skipping sync\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %s: cannot flush data on volume '%s' - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s: error when flushing data for inode %lld - %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Got EBUSY back from tx_finish!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vfsop_sync",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't set volume name \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can not start a txn to change the volume name.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s set volume name to <%s>\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s can not modify the apfs object to set the volume name (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vfsop_setattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "mountsnap_wait_(un)mount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s apfsreceived an unexpected lock-state: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_device_locked",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_device_locked busy (1)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s apfs is being LOCKED!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "handle_keybag_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s apfs is now LOCKED (flags 0x%llx)!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_device_locked busy (2)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s apfs is now UN-locked! (flags 0x%llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "handle_keybag_unlock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s attempting to tag sealed snap without entitlement\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s attempting to tag sealed snap without disabling ARV\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s attempting to tag UNSEALED snap without entitlement\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume is already set to root to snapshot \"%s\" w/snap xid %lld on next boot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Volume is already set to root to live file system on next boot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s using unsealed snapshot (%llu) as root filesystem is not supported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't set apfs_root_to_xid to xid (%llu) > apfs_revert_to_xid (%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s SET root_to_xid - on next boot, volume will root to snapshot \"%s\" w/snap xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s UNSET root_to_xid - on next boot, volume will root to live file system\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s encryption rolling is in progress, returning EBUSY\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Will cancel revert to snapshot (current revert-to xid is %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s On next mount, volume will revert to snapshot '%s' w/snap xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Can only be called from kernel\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: container_load %s, failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: could not find origin volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Origin volume is not in a volume group\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get a super block during rolemount (oid %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: could not find volume with role (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs mount failed with error %d \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get vnode for volume at fsindex = %d, role = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to mount volume at fsindex = %d, role = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vfs_ioctl",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"cannot lock inode on non-content protected volumes\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_lock_vnode_callback",
            "prototype": "",
            "backtrace": [
                "_apfs_vfs_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: apfs: mountroot called!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_vfsop_mountroot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: apfs: mountroot failed, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_vfsop_mountroot",
            "prototype": "",
            "backtrace": [
                "__ZL21external_module_allocv"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "/dev/disk%ds%ds%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_sscanf"
                },
                {
                    "string": "/dev/disk%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_container_decompose",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %sPromoting %s ino %llu DS %llu, unable to get filename, err: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %sPromoting %s ino %llu DS %llu name [%s]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %sPromoting %s DS %llu, no ino or filename is available\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s iterate_jobjs (lastOfs: %llu, startOfs: %llu) failed %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Aborting promotion for the dstream %llu because of the promotion size limit (%llu or %llu > %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to promote LBA range (0x%llx, %llu), err: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Aborting data movement for dstream %llu to allow for unmount of '%s' to proceed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Aborting data movement for dstream %llu because promotion is turned off",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Aborting data movement for dstream %llu because its inode is not eligible anymore",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion_mt_get_first_nonmapped_region(%llx, %llu) returned %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Promotion hit a dirty extent, will retry: 0x%llx -> 0x%llx, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fusion_mt_insert(%llx -> %llx, %llu) failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read data from LBA 0x%llx, %llu: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot write data to LBA 0x%llx, %llu (Read from 0x%llx): %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_rc_promote_stream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: spaceman_alloc (%llu) failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_rc_stash_range failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: spaceman_free (%llx, %lld) failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_rc_allocate_int",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Non-blocksize aligned fext: dstream %llu, offset: %llu, len: %llu\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"An out of order extent: %llu->%llx, %llu while >= %llu was expected\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_rc_extent_collector",
            "prototype": "",
            "backtrace": [
                "_fusion_rc_promote_stream"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s VNOP_STRATEGY for %s(%s,0x%llx,%llu) failed with %u : %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s buf_biowait for %s(%s,0x%llx,%llu) failed with %u : %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_data_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "e->k.old_pbn && e->v.new_pbn",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_dedupe_map_insert",
            "prototype": "",
            "backtrace": [
                "_isb_blocks_moved"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.rootless",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_strncmp"
                }
            ],
            "symbol": "_xattr_name_to_kind",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"extents must be moved in the same transaction the tmp xattr inode is deleted\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "free_xattr_tmp_ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_xf_get_ptr_and_size"
                },
                {
                    "string": "%s:%d: %s can't decrement crypto state ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tmp file extent removal under %llu failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"couldn't find name from tmp ino %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s can't remove dstream id, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_free_xattr_tmp_ino",
            "prototype": "",
            "backtrace": [
                "_apfs_setxattr_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cannot allocate %llu bytes under %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ### failed to update raw_ino %lld / %lld after adding the dstream id %lld uerr %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to decrement dstream_id for deletion for ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_alloc_xattr_tmp_ino",
            "prototype": "",
            "backtrace": [
                "_apfs_setxattr_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: bad args: apfs? %d ino? %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.private.storage.debug-apfs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_apfs_vnop_ioctl",
            "prototype": "",
            "backtrace": [
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to get host very low disk threshold, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "get_host_low_disk_levels",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to get host low disk threshold, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to get host near low disk threshold, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to get host desired level threshold, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_host_low_disk_levels",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_pinning_wbc_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_force_flush_wbc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Unknown",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_vn_getpath_ext"
                },
                {
                    "string": "%s:%d: %s %s(%u) wants to %s ino %llu DS %llu, unable to get filename, err: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %s(%u) wants to %s ino %llu DS %llu name [%s]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Promoter will be unlocked by BootCachee\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_fusion_request_movement",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: starting spillover recovery\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Cannot start metadata spillover recovery: the global extent manipulation is currently in progress\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s: error during spillover recovery on volume '%s' (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ---------------- Starting metaspill recovery\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "nx_fusion_metadata_spillover_recovery",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_global_extent_manipulation_lock"
                },
                {
                    "string": "%s:%d: %s ... NX OMAP\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_omap(nx) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ... NX OMAP mappings\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_omap_mappings(nx) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ... APFS OMAP\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_omap(apfs) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ... APFS OMAP mappings\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_omap_mappings(apfs) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ... APFS ExtentRef\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_tree(extentref) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ... APFS SnapMeta\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s nx_fusion_metaspill_fix_tree(snap_meta) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ---------------- Done metaspill recovery\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: spaceman_get() failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_fusion_metaspill_get_tier2_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_reaper_get failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_reaper_wait failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_fusion_maintenance",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_abort_spillover_recovery",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_nx_fusion_abort_spillover_recovery",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to decrement physical range (pbn %llu) (len %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_eof_extents",
            "prototype": "",
            "backtrace": [
                "_handle_share_range",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to finish all transactions in sync()! (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_fullfsync",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_fullfsync",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unable to remove XATTR_BOOTINFO error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot bless file =%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot bless non-directory file =%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to insert XATTR_BOOTINFO error=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_set_bootinfo",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to lookup dstats object on ino %lld!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_calculate_dir_stats failed on ino %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_modify failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_calculate_dir_stats",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_dir_size_base",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get iocount for graft vp: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_rdadvise",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.trim-active-file",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s cannot trim unaligned range, start: %llu, length %llu, ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_punch_hole",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s could not lookup file extent at %llu for ino %llu with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dev_unmap failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dev_unmap_flush failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_trim_active_file_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't clone extents for ino %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't get a transaction, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't update extent, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't insert extent, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FATAL: couldn't return extent to original size, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't increment reference count on crypto ID %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't create dstream for file ID %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FATAL: Some extents couldn't be transferred, no space available\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FATAL: Couldn't move some extents back to original file, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_transfer_extents",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to increment crypto state refcount (crypto ID %llu, dstream ID %llu): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not remove extent %llu:+%llu @ %llu, for ino %llu, ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to insert extent into new file\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FATAL: couldn't re-insert extent into old file, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to decrement extra crypto ref (ID %llu): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__extents_transfer_cb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.set-free-space-change-threshold",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "handle_set_free_space_change_thres",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_set_free_space_change_thres",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to transfer doc-id %d from ino %lld to %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove doc-id %d from ino %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update dst ino %lld after transferring doc-id %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update src ino %lld after transferring doc-id %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_transfer_doc_id",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "handle_reallocate_file",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_reallocate_file",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid parameters: maxCount=%u, fileIds=%llu, diffTypes=%llu, snapXid1=%llu, snapXid2=%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unexpected inode ID detected: prev %llu (xid %llu) > curr %llu (xid %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to handle snapshot diff between %llu and %llu: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_diff_snapshots",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s rewrap failed, ino %llu id %llu class %d -> %d, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_get_crypto_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_crypto_key",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_next_link",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_next_link",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_get_clone_info",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_clone_info",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't lookup file extent at %llu for ino %llu with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't lookup pext at %llu with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_is_block_shared",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s invalid length (0), pos %lld, filesize %lld, fext: obj_id %llu, laddr %llu, pbn %llu, len %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_map_file_offset ERROR[%d]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_handle_seek_holedata",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't make snapshot w/snap_xid %lld dataless because there are %lld cow-exempt files in the live-fs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't make a mounted snapshot dataless\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s snapshot is sealed, cannot make dataless\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_handle_snap_make_dataless",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Set backing store as sparse\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "handle_apfs_set_backingstore",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Backing storage is a raw file\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s init host file size to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Failed to get host file size, failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update host vfs stats, failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_apfs_set_backingstore",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "wait_for_snapshot_deletion",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_stop_bg_work"
                }
            ],
            "symbol": "_handle_wait_for_snapshot_deletion",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get next entry in omap track tree, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_omap_track_report",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_omap_track_report",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Promoter has been unlocked for %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "update_fast_promote_flag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_update_fast_promote_flag",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.storage.fusion.allow-pin-fastpromote",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "update_pinned_flags",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_pinned_flags",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_fusion_mover",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Incorrect Fusion Data movement Request type: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_fusion_mover_loop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_mover",
            "prototype": "",
            "backtrace": [
                "_nx_thread_start",
                "_nx_fusion_request_movement"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unable to pin file while Encryption state is changing",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot collect file extents for data stream %lld of inode %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tmp-ino-pinning-mover",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s Cannot create temporary file to pin data stream %lld of inode %lld  - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot pin content of data stream %lld of inode %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cancelling data movement for inode %lld to allow for unmount of volume to proceed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s moving a graft file to another tier, ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"Failed to initialize blockmap lut after moving to another tier, error %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_ioctls.c",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s%llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s Cannot force %d extents covering range %lld @ %lld of file %lld out of write-back cache - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "copy_file_extents",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate %lld bytes @ %lld in the temporary file %s - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot find extent at offset %lld in the temporary file %s, abandoning file content pinning",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reinit the blockmap lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: reinit the blockmap lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Creating a blockmap lut for the graft fs has failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_move_dstream_to_another_tier",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Bogus request to pin data at address %lld to the same device at %lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s APFS instance wants to have an exclusive access to the global lock, bailing out\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Cannot write data to %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot read data from %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate %ld bytes for temporary buffer",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_copy_phys_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot validate extent %lld@%lld for data stream ID %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Extent %lld@%lld in data stream %lld changed to %lld@%lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_validate_file_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot update extent %lld @ %lld for inode %lld - %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot update reference count for physical extents covering range of %lld blocks @ %lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_swoosh_file_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s APFS_DEBUG_OP_GET_FILE_EXTS is not supported in grafts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstreamID %llu is invalid\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s APFS_DEBUG_OP_GET_FILE_DSTREAMS is not supported in grafts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s APFS_DEBUG_OP_GET_FUSION_FILE_RC_STATS is not supported in grafts\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_panic_on_corruption set to false\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s nx_panic_on_corruption restored to %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_handle_apfs_debug",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld : sync-root-id was not set, using sync-root-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %llu: not authorized to purge directory hierarchy (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__handle_mark_purgeable",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to lookup dstats (ino %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_authorize_purge_dir_hierarchy",
            "prototype": "",
            "backtrace": [
                "__handle_mark_purgeable"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s Inserting new purgeable record / tombstones...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "_do_purge_secondary_fsroot_sanity",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to enter transaction for new purgeable records: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert purgeable tombstone: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert alt purgeable tombstone: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Inserting records succeeded!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to lookup purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to lookup purgeable tombstone: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s record didn't match content when re-looked-up\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tombstone didn't match content when re-looked-up\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to iterate secondary fs_root for purgeable records: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to iterate secondary fs_root for purgeable tombstones: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Did not find expected purgeable record contents!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to enter transaction to update purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to lookup purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Did not see updated purgeable record: (saw size %llu) %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to enter transaction to remove purgeable records: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to remove purgeable record: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found purgeable records after removing them!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Purgeable v2 sanity check succeeded!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Purge test context variables: Num purgeable records seen: %llu Num tombstones seen: %llu Last purgeable record oid: %llu Last tombestone oid: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "_print_secondary_fsroot_sanity_ctx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__do_purge_secondary_fsroot_sanity",
            "prototype": "",
            "backtrace": [
                "__handle_mark_purgeable"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unexpected record type %d found during purgeable sanity.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "_purge_secondary_fsroot_sanity_iterate_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__purge_secondary_fsroot_sanity_iterate_cb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s purging corefile\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: age for urgency set to: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: request flags: 0x%x type: 0x%x min_size: %lld: max_age %lld desired_amt: %lld (age-for-urgency: %lld, requesting uid: %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: did not find any matching files to purge (iteration: %d).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: found %d purgeable victims... deleting them.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: did not purge enough data: %lld remaining.  reduced age_for_urgency to: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Purged %lld bytes in %lld files\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_purge_files",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: reached the desired amount to delete (%lld > %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "_collect_purgeable_files_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__collect_purgeable_files_cb",
            "prototype": "",
            "backtrace": [
                "_handle_purge_files",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cancelling purge...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "purge_was_cancelled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_purge_was_cancelled",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s could not locate ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ino %lld sync_root_id is %lld but orig_sync_root_id is %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: can't get parent %lld (orig parent_id %lld) err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: could not locate ino %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: skipping ino %lld which is in use or moving (iflags 0x%llx usecount %d iocount %d).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot get parent of ino %lld in %d iterations (ino parent_id %lld; parent_id %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s ino %lld has been modified since it was marked purgeable: cur gen count %lld != stored gen count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s converting ino %lld into a fault failed with: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to move ino %lld to purgatory : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not find purgeable drec for %lld: %s %lld / %lld (name len %d; drec nlen %d); iterative removal: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_delete_inode on %lld failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s add_fsevent failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "send_purge_fsevent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": ".xyzzy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "___strlcpy_chk"
                }
            ],
            "symbol": "__remove_purgeable_file",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to allocate the lookup drec for %s / %lld / parent-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s re-using existing decmpfs xattr for new ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xf_get docID failed with %d on on ino %lld \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_inode_doc_id docID(%u) failed with %d on on ino %lld \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ret %d failed to move ino %lld to purgatory\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_convert_dir_into_dataless_fault",
            "prototype": "",
            "backtrace": [
                "__remove_purgeable_file"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%spurging-%lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s ret %d failed to insert purgator record for tmp_ino %lld for ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set new dstream on ino %lld ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_convert_file_into_dataless_fault",
            "prototype": "",
            "backtrace": [
                "__remove_purgeable_file"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s looking for files to clear purgeable on.... (req flags: 0x%x type %d uid %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "handle_clear_purgeable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Cleared purgeability on %lld files\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_clear_purgeable",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s volume %s has unexpected purgeable-fixup xattr size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume %s needs purgeable drec fixup.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s searching for purgeable dups/clones on %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "setup_purgeable_fixup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found %lld dups/clones on %s (num & max ids: %d / %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "finish_purgeable_fixup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s NOT setting the purgeable-drecs-fixed xattr on the root dir of %s because we maxed out the number of seen id's\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set the purgeable-drecs-fixed xattr on the root dir of %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_purgeable_stats",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not fetch dup file-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %lld is no longer purgeable.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__fixup_purgeable_drecs_cb",
            "prototype": "",
            "backtrace": [
                "_handle_get_purgeable_stats",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld is not purgeable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get dstats info for ino %lld : %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s did not find purgeable drec for ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_purge_single_file",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Too many cancellations running!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Adding cancellation request...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "wait_for_purge_cancellation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_stop_bg_work"
                }
            ],
            "symbol": "_handle_cancel_purge",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_set_sync_root_flag",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_set_sync_root_flag",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s RC eviction: %llu blocks starting from LBA %llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s RC demote: eviction for %llx, %llu failed, %llu blocks were evicted (%llu left unprocessed), err %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s RC demote: eviction for %llx, %llu completed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Set(%llx) and clear(%llx) flag sets should not intersect each other\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Spillover recovery is bailing out\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_modify failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Scanning fexts for the range [%llx, %llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Done scanning fexts, found %llu dstreams%s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Scanning fexts, looking for the MT mapped regions\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Done scanning fexts, found %llu dstreams%s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_fusion_debug",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: fusion_mt_demote_extent(%llx, %llu) returned %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_debug_demoter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_demote_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_debug_demoter",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_debug",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s iterate_jobjs(ofs: %llu) failed %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to flush LBA range (0x%llx, %llu), err: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_debug_chunked_flusher",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_debug",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Out of memory :(\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_fusion_find_lba_owner_checkForNewEntry",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_find_lba_owner_checkForNewEntry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Scan failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Found nothing\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Inodes scan has finished, found %llu out of %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Buffer size %llu was able to fit only %llu records, exiting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_nx_fusion_find_lba_owner_scanInodes",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_debug",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fusion_mt_count_rc_blocks(%llx,%llu) falied with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_fusion_find_lba_owner_fext_MT_scanner",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Length is zero\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_find_extent_mapping(%llx,%llu) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_find_lba_owner_fext_MT_scanner",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_debug",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s omap_evict_state_init failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_metaspill_fix_omap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tree_evict_state_init failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s obj_modify failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_metaspill_fix_tree",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tx_finish failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx_finish #2 failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_fusion_metaspill_flush",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_maintenance",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "handle_unmount_crypto_hint",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_unmount_crypto_hint",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: BootCache requested optimization for %d inodes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "handle_bc_optimize_inodes",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s BootCache inode optimization is not supported on SSDs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s BootCache inode optimization is not supported on non-sealed systems booted from snapshot",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s APFSIOC_BC_OPTIMIZE_INODES flags %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_bc_optimize_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Inode %lld on volume %s is pinned to the capacity tier and used during boot, consider removing the pinning\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_handle_bc_optimize_inodes",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to lookup root-snapshot-name, failing the lookup request - %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get snapshot metadata object, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_snapshot_lookup",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_make_object_dataless",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_make_object_dataless",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s key rolling : unknown operation: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_key_rolling_op",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s encryption rolling is disabled for this device.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "key_rolling_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "key_rolling_stop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s encryption rolling is disabled for this device.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "key_rolling_resume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "key_rolling_pause",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "roll_new_crypto",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "roll_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "roll_new_xattr_crypto",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot enter debug call %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "roll_xattr_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_handle_key_rolling_op",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.keyrolling.operation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_is_ier_operation_allowed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.apfs.keyrolling.internal.debug",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_is_ier_internal_debug_task",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s pfku rolling : unknown operation: %u",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_pfku_rolling_op",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.apfs.pfkurolling.internal.debug",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "pfkur_rolling_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "pfkur_rolling_stop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "pfku_enqueue_request",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to load pfkurso for ino %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s pfkurso is missing for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not locate pfkurso for ino %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_pfku_rolling_op",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Not a directory %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Device has role %x which is not a system volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Device is not in a volume group\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s firmlink target name %s is too large (length %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.private.apfs.set-firmlink",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s Invalid target path\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Target path %s is not a valid firmlink target path for volume group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Target path %s is not a directory. volume group %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Add extented attribute FIRMLINK_EA_NAME %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fs_add_xattr failed with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_remove_xattr failed with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s update_jobj failed with err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Already set\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_firmlink_ctl",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Synthetic folder name unterminated / too long\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Synthetic folder name '%s' is prohibited!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create the new directory entry and inode %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_create_synthetic_folder",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "handle_volume_class_keybag_op",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_volume_class_keybag_op",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs wait_until_keybag_state",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_wait_until_keybag_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Synthetic symlink name unterminated / too long\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Synthetic symlink name '%s' to target '%s' is prohibited!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Synthetic target path unterminated / too long\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create the new symlink entry for symlink_inode %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to create symlink xattr (error %d) on ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_create_synthetic_symlink",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to revert modifications to BSD flags with error (%d) after initial failure (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "handle_cas_bsdflags",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_cas_bsdflags",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "collect_extents_by_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_collect_extents_by_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s src_offset (%llu) and dst_offset (%llu) must be the same in content protected volumes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid sizes - length: %llu, src_offset: %llu, dst_offset: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to authorize dst file (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s both src (ino %llu) and dst (ino %llu) files must be on the same volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to authorize src file (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src (ino %llu) and dst (ino %llu) must be different regular files\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src (ino %llu) must not be a namedstream\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src (ino %llu) and dst (ino %llu) must not be raw encrypted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src (ino %llu) cannot be a compressed file\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dst (ino %llu) is a dataless file, and the caller is unprivileged\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dst (ino %llu) cannot be a non-dataless compressed file\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to sync files (src ino %llu, dst ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src file (ino %llu) no longer exists\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dst file (ino %llu) no longer exists\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s src (ino %llu) and dst (ino %llu) must be of the same protection class\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not retrieve source dstream (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s range in src file (ino %llu) must be entirely in file (src_offset: %llu, len: %llu, size: %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s merge_holes_if_needed failed (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to lookup file extent at pos %lld (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s range in dest file (ino %llu) must be free of data\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s range in dest file (ino %llu) must be free of data and big enough\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sharing to the end of a non-block-aligned file is not allowed (dst ino %llu, size %llu, offset %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove EOF extents before sharing (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dst (ino %llu) is a dataless file, but the range is not properly aligned (offset %llu, length %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s len is not a multiple of the block size (len: %llu) but sharing is not from the end of src to the end of dest\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not clonesplit from raw encrypted clone on dst file (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not clone_extents_if_needed() on dst file (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not create dst dstream (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to move fexts from src (ino %llu) to dst (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to load pfk upgrade rolling state object for dst (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to load pfk upgrade rolling state object for src (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update pfk upgrade rolling state object for dst (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update_sparse_bytes() (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not retrieve dest dstream (ino %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_share_range",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to enter transaction sized %d (ino %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to update hole extent (ino %llu) (offset %llu) (len %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to remove extent (ino %llu) (offset %llu) (len %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_remove_jobj"
                }
            ],
            "symbol": "_merge_holes_if_needed",
            "prototype": "",
            "backtrace": [
                "_handle_share_range",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_xdstream_obj_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_xdstream_obj_id",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s lookup takes place in a volume group, but the source volume is not in one\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s lookup takes place out of a volume group, but the source volume is in one\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s 'where == %d' is invalid\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not find volume with role 0x%x in (container/volume group) %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "/dev/%ss%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s device path is too long (%d > %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.apfs.get-dev-by-role",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_handle_get_dev_by_role",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_eval_rootauth",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_eval_rootauth",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume is not sealed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume seal is broken\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get root hash: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Invalid root hash: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_eval_roothash",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot copy out %d bytes: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_file_hash_record",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_drop_extents_in_snap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_drop_extents_in_snap",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't start txn to drop extents from snap (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get snapshot tree oid %lld : %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get live extentref tree : %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s no pexts found for cur_pbn %lld; have they already been dropped?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s how odd... got err %d cur_pbn %lld was not found in snap extents tree\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found phys-block %lld (len %lld owning-obj-id %lld refcnt %d kind %d) not %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s bogus looking phys_ext %lld:%lld kind %d owning_obj_id %lld refcnt %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d removing pext key 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d updating phys block num %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s pext key 0x%llx kind %d len %lld owning_obj_id %lld refcnt %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d updating pext key 0x%llx (len %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to lookup phys block num %lld in snapshot tree : %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update snapshot meta! error %d (snap_extents oid %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_drop_extents_fext_iterator",
            "prototype": "",
            "backtrace": [
                "_handle_drop_extents_in_snap",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "handle_revoke_children",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_revoke_children",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Invalid flags: 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Sync is already in progress\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_ongoing_mounts_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s cannot sync and freeze: Container-wide extent manipulation is in progress, %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot sync and freeze: failed to sync all volumes, %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not sync and freeze: failed to freeze container, %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_sync_and_freeze",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unknown ioctl %s('%c', %lu, %lu) (0x%lx), pid = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s unknown ioctl 0x%lx pid = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_print_unknown_ioctl",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s Graft version %u not supported.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Malformed arguments for image4 payload or manifest\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to validate image4 payload and manifest for grafting: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Need superuser to graft an FS\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "validate_grafting_cred_and_flags",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_fsioc_graft",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.get-graft-info",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s getting graft info requires an entitlement\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume has %d grafts but buffer can contain only %d records\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to allocate memory for %d graft info records\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %lld marked as in a graft, but no matching graft for it was found!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_graft_info",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.get_preallocate_min_space",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_handle_get_preallocate_min_space",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.private.apfs.trim_preallocated_space",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: %s failed to trim preallocated space: error %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_release_preallocated_space",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"apfs_lock_io_lock_pair() was called with invalid arguments\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_lock_io_lock_pair",
            "prototype": "",
            "backtrace": [
                "_handle_share_range",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"jhash_insert: apfs object with a non-null list.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"jhash_insert: apfs object with a zero devt.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_jhash_insertvnode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"jhash_try_insert: apfs object with a non-null list.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"jhash_try_insert: apfs object with a zero devt.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"cannot insert reserved, un-busy jhash object\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_jhash_try_insert_stream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_jhash_removevnode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"jhash_removevnode: apfs object with a zero devt.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_jhash_removevnode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s resolver performing a op %llx on a file which is still being materialized",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s resolver returned EJUSTRETURN for unexpected op %llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s resolver returned 0 on file which is still dataless, op %llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_materialize_dataless_file_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs: total mem allocated: %lld (%lld mb) (num failures: %d, last failed size: %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                },
                {
                    "string": "apfs: total mem allocated: %lld (%lld mb);\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_printf"
                }
            ],
            "symbol": "_apfs_print_mem_stats",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_get_volume_group failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_get_paired_volume",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs_vfsop_vget failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to alloc memory for relative path\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fs_get_xattr failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vnode_lookupat(%s) does not belong to paired data volume returning ENOENT\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s vnode_lookupat(%s) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_get_firmlink_target_vnode_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_get_volume_group volume %s, failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_is_original_volume_group_system_vol",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_is_original_volume_group_system_vol",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "kern.development",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_sysctlbyname"
                },
                {
                    "string": "-arv_allow_fv",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: %s Filevault is not allowed when ARV seal is broken\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_filevault_allowed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_filevault_allowed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fs_private_get_tx_active",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_private_get_tx_active",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "rootdev",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                }
            ],
            "symbol": "_rootedRamdisk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"%s: Both inodes are NULL\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_lock_inode_pair_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_lock_inode_pair_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"found a reserved, non-busy jhash object\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s vp has different mp than fs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_jhash_getvnode_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_jhash_getvnode_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s object %lld / %p has bad dev\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "object_in_jhash",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"jhash_getvnode: bad devt on object.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"reserved jhash objects should be busy\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"can't have a namedstream vnode without a valid name\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_object_in_jhash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fs_private_get_lock_acquired_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_private_get_lock_acquired_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_lock_stream_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_apfs_lock_stream_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "\"System ObjId overflow\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Data ObjId overflow\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_get_next_apfs_obj_ids",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ***: expanded obj type %d (obj_id %llu) found on unsupported volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "%s:%d: %s Cannot make large jkey from unknown type %d (obj_id %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "make_large_jkey_header_from_jobj",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_make_jkey_from_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s large key size (%u) on record (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "%s:%d: inserting bad phy ext @ %p : kind %d refcnt %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"bad pext.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s File extent too large (%llu > %llu): laddr %llu, paddr %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"fext %lld (pos %lld len %lld flags %x can not have crypto-id -1\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to serialize ino %lld into jval of size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to serialize drec %lld/%s into jval of size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to serialize purgeable %llu into jval of size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to serialize dir-stats %lld into jval of size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jobj_to_key_val",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Unknown subtype %d for file info object %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ***: expanded type seen on in-memory obj\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_create_or_modify_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s key size (%zu) on expanded record (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "jobj_validate_key_val",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jobj_validate_key_val",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: *** Can't release unknown obj type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "jobj_release",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jobj_release",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Shadow fs_root already exists: %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Created the shadow_fs_root tree %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get inode %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed during copy of root directory entries into the shadow fs_root, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_setup_shadow_fs_root_tree",
            "prototype": "",
            "backtrace": [
                "_handle_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Shadow fs_root does not exist\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Deleted the shadow_fs_root tree %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: obj is NULL or not apfs object!",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ROSV: Deleting the shadow_fs_root tree 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ROSV: failed to delete shadow fs_root: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_release_objects",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to get fext tree w/oid %llu (modify_xid %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get pfkur tree w/oid %llu (modify_xid %llu): %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jfs_get_tree_in_snap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"sealed, fext, req_tree != fs_root\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"type = %u, req_tree != fs_root\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Warning: attempting to place unknown expanded type %hhu into fsroot.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_match_jobj_type_to_tree_type",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to insert fext in fext_tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Trying to insert a namedstream inode %llx on volume %s\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s X %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "addition",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_prevent_synthetic_object_operation"
                }
            ],
            "symbol": "_insert_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "update_jobj",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Trying to update a namedstream inode %llx on volume %s\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "modification",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_prevent_synthetic_object_operation"
                }
            ],
            "symbol": "_update_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fext_tree_remove returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "remove_jobj",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "removal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_prevent_synthetic_object_operation"
                }
            ],
            "symbol": "_remove_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to init extended fields on inode %lld from blob (xfret %d).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to init extended fields on drec %lld from blob.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s cannot translate key-val (%llu) into valid jobj\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: *** unknown obj type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "jobj_size_for_key_val",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** unknown expanded obj type %hhu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "jobj_size_for_large_key_val",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "%s:%d: unknown expanded type (%hhu) on record (%u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: *** Can't allocate unknown obj type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_key_val_to_jobj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "lookup_jobj_in_snap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_lookup_jobj_in_snap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot allocate %zu bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_get(volume: %s) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found OBJID 0x%llx type %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s tree_lookup_ge(volume: %s) failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_lookup_ge_jobj_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "update_file_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_file_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"apfs_unlock_phys_range num_locks==0\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"apfs_unlock_phys_range lock %d not taken\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_unlock_phys_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"apfs_lock_phys_range first_pbn 0, last_pbn 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_lock_phys_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_apfs_lock_phys_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s invalid ref count %d for non NULL zero ref tree\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid zero len, paddr %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_remove(%llu) failed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_free_data_blocks_if_needed(%llu,%llu) failed: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Attempted to %s range %llu+%llu but it isn't entirely there! (found gap at %llu, next range at %llu+%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "reference",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "dereference",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_update_phys_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!((err == 0) && (*crypto_id == 0) && fs_is_content_protected(apfs))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino_has_vnode(ino)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"invalid crypto id\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s crypto_obj_insert of new crypto_id %lld should not have failed (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "icp_new_crypto",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"apfs_crypto_state_init: invalid key length! (%ul) \\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"apfs_crypto_state_init: invalid iv key length! (%ul) \\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: AKS new_key failed for class = %d, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_new_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_new_crypto_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s buffer not allocated, extents %s, recovery %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion buffer not allocated, mappings %s, roll_extents %s, flush_ctx %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s buffer already allocated, extents %s, recovery %s, mappings %s, roll_extents %s, flush_ctx %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_state_allocate_roll_buffers",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s size phys 0x%x, needed at least 0x%lx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error entering TX while upgrading erso version: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error modifying apfs while upgrading erso version: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error modifying erso while upgrading version: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to leave tx while upgrading erso version: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s upgraded erso to version %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_er_state_upgrade_version",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No ER state object for volume %s - rolling is not happening, nothing to recover.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to get ER state object for recovery check: error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get bitmap for recovery: error = %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error getting bitmap during state recovery, oid is 0, EIO.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not allocate roll buffers\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s gbm_run: Unable to size main Fusion device: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: error %d importing recovery state\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: ersb_recovery_length is 0\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: ersb_recovery_length 0x%llx exceeds allocated recovery buffer length 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: error %d reading recovery data, extents_count 0x%llx, recovery_length 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: recovery len mismatch, ersb_recovery_length 0x%llx, read 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: error %d recovering extent, idx 0x%llx, dstream_id 0x%llx, fext_laddr 0x%llx, fext_pbn 0x%llx, fext_cid 0x%llx, pbn 0x%llx, len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: er: recovered %d bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: checksum_count 0x%llx requires recovery buffer len 0x%llx, exceeds buffer len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: checksum_count 0x%llx, data_size 0x%llx, exceeds phys size 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ersb_recovery_list_oid 0\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d getting recovery block oid 0x%llx, offset 0x%llx, length 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s recovery list offset mismatch, accum 0x%llx, list 0x%llx, len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s copy_len==0, o_size_phys %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s missing recovery data, accum 0x%llx, recovery_length 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s recovery list has data past recovery_length 0x%llx, offset 0x%llx, oid 0x%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error reading data with old crypto during state recovery: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error reading data with new crypto during during state recovery: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid checksum, dstream_id 0x%llx, fext_laddr 0x%llx, fext_pbn 0x%llx, fext_cid 0x%llx, pbn 0x%llx, len 0x%llx, byte_off 0x%llx, checksum_block_off 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: read rolled data: key rolling is not supported.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: read rolled data: unknown flags: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"WTF?!\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ersb_flags: 0x%llx, ersb_recovery_extents_count: 0x%llx, ersb_current_fext_obj_id: 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s RO mount -- holding extra reference on er_state_obj: %llu.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_encryption_rolling_mount_check",
            "prototype": "",
            "backtrace": [
                "_apfs_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d getting ER state object, oid 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid ER state object version %d, current is %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_state_obj_get",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error locking physical range during blockmap contiguous check.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error getting er state during blockmap contiguous check: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error getting er bitmap during blockmap contiguous check: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: er blockmap check: HITTING ZERO: pbn=0x%llx *run=0x%llx first_zero=0x%llx first_one=0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_er_check_contiguous_blockmap",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_blockmap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: er: phys init: size: %u sizeof: %lu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er_state_init_phys",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_er_state_init_phys",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: error %d creating physical object from version %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_state_init_obj",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: error allocating memory for current version physical object\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_state_init_obj",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s er: read unrolled data: key rolling is not supported.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: read unrolled data: unknown flags: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_read_unrolled_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d getting recovery block oid 0x%llx, length 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s non-increasing offset, current 0x%llx, last 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_recovery_delete",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 3,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d deleting recovery data\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d creating recovery block object, offset 0x%llx, len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s data_size==0, o_size_phys %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_recovery_write",
            "prototype": "",
            "backtrace": [
                "_er_roll_window"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s ER: error %d getting blockmap bit for paddr 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "cp_get_fext_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"ER: raced with ER FINISH more than once!\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "id != 4",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"invalid attempt to unwrap extent-key for an \" \"xattr\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!xattr_is_class_v(apfs)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot get xattr ek %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot unwrap xattr ek %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_cp_get_fext_ek",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to %s crypto-id %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "update",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error initializing class %d crypto state (crypto id %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_change_crypto_id_prot_class",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to update dstream on namedstream inode %llu for inode %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update dstream on xdstream %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to change xdstream prot class (xdstream %llu default crypto id %llu error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s change_xdstream_prot_class failed on ino %llu (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "change_prot_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_change_prot_class",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_setattr"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "retain_xdstream_crypto_states",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_retain_xdstream_crypto_states_cb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to retain file dstream crypto states (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to retain xattr dstream crypto states - crypto state ref counts may now be off (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_retain_crypto_states",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to update dir size key %lld for ino %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_insert_jobj"
                }
            ],
            "symbol": "_update_dir_size_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino_phys_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_ino_phys_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to set dstats key %lld from to_dir %lld on ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_dir_stats_moved",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "get_purgeable_flags_from_drec",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_purgeable_flags_from_drec",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s : %s clearing purgeability on ino %lld (%s ; parent-id %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "_clear_purgeability_log",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "__clear_purgeability_log",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s The directory hierarchy rooted at ino %llu was modified - please retry.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %lld has a sub-dir and can't be marked purgeable.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dir %lld has %lld bytes inside of it\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set the dir-gen-count xf field on the purgeable drec for ino %lld : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s did not find purgeable drec <%s> for ino %lld (parent id %lld) (fsize %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s did not find the purgeable drec iteratively (err %d).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_set_ino_purgeable_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s updated purgeable state on ino %lld w/timestamp: %lld (err %d) name %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_ino_purgeable_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld has a sub-dir!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove old purgeable drec name %s for ino %lld (new_uid %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert new purgeable drec name %s for ino %lld (new_uid %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_ino_purgeable_drec",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dir %lld has a sub-dir!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "update_directory_purgeable_drec",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s did not find old purgeable drec name %s for dir %lld (fsize %lld size_delta %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove old purgeable drec name %s for dir %lld (fsize %lld size_delta %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert new purgeable drec name %s for dir %lld (fsize %lld size_delta %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_directory_purgeable_drec",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get the real drec dir-gen-count %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to make the purgeable drec %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to make purgeable name (file-id 0x%llx size 0x%llx owner %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to lookup dstats key %lld for ino %lld : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_purgeable_dir_gencounts",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s *** failed to set dstream as an extended field of ino %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** failed to fetch the dstream pointer for %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_create_dstream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "move_inode_to_purgatory",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_move_inode_to_purgatory",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"%s cannot be called for namedstream inodes\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: couldn't allocate memory for link origin\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_insert_linkid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s():%d: dir_nlink = %d for inum %lld, removing %lld?!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s():%d: xf-nlink count = %llu for inum %lld, removing %lld?!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "___apfs_dec_parent_nlink",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove sibling hard link entry for ino %lld under hardlink/sibling key %lld/%lld w/drec %lld:%s (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove drec %lld:%s ino %lld ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_dir_entry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s removing xattrs returned ENOENT for private-id %lld (ino %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s decrement dstream id returned ENOENT for private-id %lld (ino %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ino %lld failed to remove purgatory entry: iflags 0x%llx internal_flags 0x%llx isdir: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s parent is %lld name is %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_delete_inode_with_xid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove extent for extent-id %lld @ logical offset %lld:%lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to decrement crypto state = %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to decrement physical range pbn=%llu len=%llu for obj-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_extent_of_file",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"res->xid %lld but xid is now %lld\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_do_iterative_file_extent_removal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s could not lookup dstream-id %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "iteratively_remove_extents_of_file",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_iteratively_remove_extents_of_file",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s %s: could not insert dir rec for obj-id %lld (name: %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** failed to set rdev as an extended field of ino %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s: could not insert inode obj-id %lld (name: %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update parent ino %lld nchildren field on create of %s (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_obj_create_name_checked",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Adding children to an auto-mount directory is not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_obj_create_prepare_and_lock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_obj_create_prepare_and_lock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to create object named %s in dir w/obj-id %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_obj_create_do",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: DANGER! got the same extent for logical addr %lld twice!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fext_collector",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fext_collector",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"can't return crypto_id if it's a tweak\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fext_get_crypto_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"invalid crypto id %llu\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fext_set_crypto_id_for_new_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "decrement_dstream_id_refcnt",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_decrement_dstream_id_refcnt",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s restoring refcnt on dstream_id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "decrement-dstream-id-for-deletion",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_unretain_crypto_states"
                }
            ],
            "symbol": "_decrement_dstream_id_for_deletion",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cannot set dstream on %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot persist dstream to %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot add new dstream to %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_alloc_tmp_ino_with_crid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't remove dstream id %lld, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't remove tmp inode %llu (%s) from disk, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_free_tmp_ino",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cloning_err %d must_join_current_txn %s xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert extent for ino %lld @ logical offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to increment physical range pbn=%llu len=%llu for obj-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_iterative_fext_cloner",
            "prototype": "",
            "backtrace": [
                "_iteratively_clone_extents_of_file",
                "_clone_extents_if_needed_with_gst"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s lookup_file_extent failed: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "is_non_iterative_extent_manipulation_faster",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_is_non_iterative_extent_manipulation_faster",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ino %lld (%s) could not get a new crypto-id (ret %d gencount %d xid %lld)!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ino %lld (%s) is a graft image file, graft_state must be non NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clone_extents_if_needed_with_gst",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s *** failed to set dest dstream on ino %lld (from %lld, ret = %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s source inode(%lld) marked sparse, but missing extended field\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set sparse byte count on inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s0x%llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s Failed to insert new dir_rec for %s (fid %lld) in parent-dir 0x%.16llx (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s clone %lld has a dir-size-key (%lld) but internal_flags are wrong (0x%llx)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** failed to update source %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update pfk upgrade rolling state object for cloned inode %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: cannot clone %llu dstream crypto, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s *** failed to insert clone inode %lld (dir %lld/%s, ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s could not remove xattrs for obj-id %lld: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s could not remove obj-id %lld: %s (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clone_item",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to load inode %lld ret %d on volume: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_get_inode_with_hint",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_get_inode_with_hint",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "clone_ea_ctx.err != (-1)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_clone_xattrs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s name <%s> is TOO LONG! (%d / max %d)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to get the new parent ino %lld (for cloning from %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s could not fetch new clone %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert dest_drec %lld:%s err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to alloc temp clone drec (name %s, err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove temp clone name %s in private dir (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to set new name %s on clone\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to alloc dir rec in error path, err=%d ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s there should have been an entry for the name %s ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert dead record in purgatory for failed clone w/ino # %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_obj_clone_name_checked",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to fetch crypto for crypto_id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "jdev_fext_read_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jdev_fext_read_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"ino %lld pos:len %lld:%lld fext %lld:%lld (%lld)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"ino %lld illogical file extent %lld:%lld != alloced_size %lld (fsize %lld)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s ino %lld file extent %lld:%lld extends beyond alloced_size %lld (fsize %lld). fixing it.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s spaceman_alloc() FAILED, err: %d xid: %lld paddr: %lld blocks requested: %lld blocks allocated: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"we asked for %lld blocks but got %lld (orig %lld, blks_this_allocation %lld)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"we asked for %lld blocks but got zero (paddr %lld) from spaceman_alloc() and no error.\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed inserting hole %lld:%lld (pos %lld, len %lld alloced_size %lld) err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to extend existing extent %lld:%lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_alloc_space_for_write_with_hint",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot start transaction with XID %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unexpected unwritten extent for offset %lld of data stream %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot reach %lld from %lld, gap at %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot construct reservation list for sparse extent for %lld bytes at offset %lld in inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s Not enough reserved ranges to reach position %lld in inode %lld from %lld:%zu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s On %d iteration got extent %lld:%lld->%lld which does not start at offset %lld of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s On %d iteration got allocated extent %lld:%lld->%lld which overlaps with the reserved range %lld:%lld,%d of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s iteration %d - range %lld:%lld,%d does not include offset %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"iteration %d - found unreserved range at offset %lld in inode %p for extent %p, range points to %p(%lld:%lld,%d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s iteration %d - found unreserved range at offset %lld in inode %lld for extent %lld at %lld, range points to %lld:%lld,%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot assign %lld blocks to file extent of %lld bytes at offset %lld to dstream %lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate reserved space for %lld bytes at offset %lld in dstream %lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Allocated reserved space for %lld bytes at offset %lld in dstream %lld of inode %lld: extent %lld:%lld->%lld does not match range %lld:%lld,%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot allocate space for %zu bytes at offset %lld in dstream %lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot mark space for %zu bytes at offset %lld in dstream %lld of inode %lld as writable: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot restore unwritten status of extent at offset %lld in dstream %lld of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to add dirty work item for ino %lld (%lld:%lld) err %d xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_map_file_offset_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Error! tree_lookup_le of %lld:%lld returned %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error! tree_lookup_ge of %lld:%lld returned %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fetch_particular_snap_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s xattr %lld:%s err %d decrementing crypto state id %lld (xattr dstream id %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fs_remove_xattr_with_nstream_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fs_remove_xattr_with_nstream_inode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Sparse bytes removed from inode %lld internal flags: 0x%llx iflags 0x%llx, new_sparse_bytes %lld; name %s parent-id %lld), but it wasn't marked sparse.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Sparse bytes removed from inode %lld that didn't have an extended field.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to remove sparse bytes attribute from ino %lld, but it was successfully got, errro %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Couldn't set sparse bytes extended attribute on ino %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_update_sparse_bytes",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!\"cannot convert class V\"",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_to_cp_class",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get dstream when unretaining %llu for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "is_retainable",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_is_retainable",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fs_get_snap_meta",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_get_snap_meta",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs_snap_oxid should be %llu but it's %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_update_snap_vol_carefully",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_mtx_unlock"
                },
                {
                    "string": "%s:%d: %s apfs_main_apfs should be %p but it's %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_update_snap_vol_carefully",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Snapshot %llx is not the oldest one\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "fs_can_manipulate_snapshots_extents",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_fs_can_manipulate_snapshots_extents",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs must point to a live view\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Live view reverted to snapshot but not yet mounted RW, cannot evict\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_evict_range",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to fetch sub-dir ino %lld.  assuming it was deleted or renamed.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__get_inode_with_lookaside_and_hint"
                },
                {
                    "string": "setup_dir_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__get_inode_with_lookaside_and_hint"
                }
            ],
            "symbol": "_setup_dir_size",
            "prototype": "",
            "backtrace": [
                "_set_maintain_dir_size"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s will chain updates on %lld back up to dstats-key: %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to insert dstats object on ino %lld!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update ino %lld to flag it as maintain-dir-stats and dir-stats-origin\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_set_maintain_dir_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "get_dir_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_dir_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s old reserve was %lld, num_blocks %lld. blocks_in_txn_counter %lld num_active_txns=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s gettin' low on space: ttype %s num_blocks %lld blocks_in_txn %lld free_blocks %lld xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_fs_tx_leave_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s couldn't freeze the file system (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_tx_freeze",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_tx_freeze",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s couldn't thaw the file system (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_tx_thaw",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_tx_thaw",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get fsys idx=%u oid=%llu: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx and apfs superblock disagree on fs_idx, nx_idx=%u, nx_oid=%llu, apfs_idx=%u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot delete encrypted volume in demo mode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Container-wide extent manipulation is in progress, cannot delete volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can not delete a volume that is already mounted/deleting/replicating\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to enter transaction, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to add file system to reaper: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_deletefs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to mark doc-id index for rebuild, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to clean up doc-id trees, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s prepare for rebuild, doc_id_index_flags 0x%x, doc_id_tree_oid %llu, prev_doc_id_tree_oid %llu, doc_id_tree_type %u, apfs_next_doc_id %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to delete prev doc-id tree (no tracked files), error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume marked for doc-id index rebuild but does not support index (role %d, flags 0x%x)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s prev doc-id tree oid is non-zero (%llu), but index is not being built (flags 0x%x), deleting prev tree\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_check_stale_doc_id_index",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to mount livefs as volume is restoring or mounted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_mount_livefs",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s can't mount root filesystem writeable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unsupported apfs_readonly_compatible_features (%llx): mount r/o\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s spaceman_info() shouldn't have failed, ignoring.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s mount no firmlinks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to fetch the fext tree (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to fetch the integrity object (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot load the filesystem root tree: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Cannot load the secondary filesystem root tree: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to fetch the extentref tree (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to fetch the pfkur tree (error %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_mount_livefs",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s EALREADY; rooted from snap, apfs %p\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Can't mount a volume undergoing restore/livefs-create\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s encryption type %llx unsupported\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unsupported apfs_incompatible_features (%llx): unable to mount\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume is incompletely restored and needs to be cleaned up\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s mount for ramdisk\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Cannot retrieve key from boot_args for root: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to unwrap metadata crypto state: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ER state object present, but failed to fetch, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_mount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_fixup_thread_exit",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "apfs-unmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_buf_flushdirtyblks"
                },
                {
                    "string": "%s:%d: %s Releasing extra RO reference on er_state_obj\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_unmount",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "-apfs_crypto_leak_panics",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: %s active crypto object! id %llu retain count %d class %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "crypto_cache_destroy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_unmount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Volume role 0x%x is not allowed for an unencrypted volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot change role of xART volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "com.apple.private.apfs.xart",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                },
                {
                    "string": "%s:%d: Creating an xART volume without entitlements is not allowed.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Volume role 0x%x is not supported in container",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get fsys oid %lld - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume role 0x%x already exists in container uuid %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Encrypted volume is not allowed with special role = 0X%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Volume role 0x%x already exists in volume group uuid %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot change volume role 0x%x in volume group uuid %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_is_volume_role_allowed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unable to remove Fusion MT mapping for LBA %llx, size %llu : %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman_free failed for LBA %llx, size %llu : %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_free_data_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot join transaction %lld to reserve %lld blocks for inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot reserve %llu blocks for inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Underflow detected in reserved ranges counter for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Underflow detected in unwritten ranges counter for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Number of bytes in new ranges %lld for inode %p does not match number of blocks %lld\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Number of bytes in new ranges %lld for inode %lld does not match number of reserved blocks %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Entry at %p already in the list for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_make_space_reservation",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cannot update inode flags for inode %llu: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot save previous file size on inode %llu: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot start transaction to save previous file size of inode %llu: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_update_prev_fsize",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!(ino->iflags & (JI_NAMEDSTREAM | JI_RAW_ENCRYPTED))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "scalable_id_is_valid(rsrcfork.dstream.default_crypto_id)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_cache_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!(src->iflags & JI_NAMEDSTREAM) && !(snk->iflags & JI_NAMEDSTREAM)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_xchg_ekwk",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_exchange"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->iflags & JI_NAMEDSTREAM",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_rsrc_uncache_ekwk",
            "prototype": "",
            "backtrace": [
                "_apfs_lock_vnode_callback",
                "_apfs_vfs_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot get on-disk ekwk %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot unwrap ekwk %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_get_unwrapped_ekwk_snap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"cannot overwrite vek\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino_get_class_or_none(apfs, ino) != ino_class_v",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"%s:%u: \" \"cannot get ekwk ino %llu, id %llu, %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "mcp_chclass_sb_has_ino(sb)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "mcp_chclass_sb_has_rsrc(sb)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot derement old id %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "mcp_chclass_apply",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "sb->ino.new_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "sb->rsrc.new_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_mcp_chclass_tx",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_setattr"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "(((src->mode) & 0170000) == 0100000)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot insert rsrcfork %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot clone rsrcfork fexts %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot remove resource fork %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "new_rsrc_clonesplit_src",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: key %u generation failed %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "cp_new_crypto",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "id == id_mut",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot deref staged ek %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "clonesplit_rsrc_snk_free",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_clone_rsrcfork",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "src->iflags & JI_HAS_RAW_ENCRYPTED",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "snk->iflags & JI_RAW_ENCRYPTED",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_raw_clone_fexts",
            "prototype": "",
            "backtrace": [
                "_apfs_raw_encrypted_clone"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s prev doc-id lookup failed, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "get_file_id_by_doc_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_fixup_thread_lookup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_doc_id_tree_lookup"
                }
            ],
            "symbol": "_handle_doc_id_to_file_id",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume inconsistency detected by %s:%u!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_mark_inconsistent_",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "(get_vol_crypto(apfs) == VOL_PFKEY) ? (crypto_id == 4) : 1",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "legacy_get_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"apfs_unwrap: invalid key length! (%u)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"apfs_unwrap: invalid iv key length! (%ul)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: AKS unwrap_key failed, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_unwrap_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_legacy_get_ek",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "sr_remove_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fext_get_crypto_id"
                },
                {
                    "string": "%s:%d: %s failed to remove extent %lld %lld:%lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_sr_remove_fexts",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ***: expanded obj type found on unsupported volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s no key passed, exiting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s key size (%zu) on purgeable record (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s value size (%zu) on purgeable record (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s key size (%zu) on purgeable tombstone (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s value size (%zu) on purgeable tombstone (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s value size (%zu) on dir stats (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s value size (%zu) on unknown record (%llu) is too small\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jobj_validate_large_key_val",
            "prototype": "",
            "backtrace": [
                "_jobj_validate_key_val"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"refcnt overflowed on dstream id 0x%llx refcnt %d (delta: %d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"can't have a negative refcnt on crypto state 0x%llx refcnt %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: don't know how to merge refcounts on objects of expanded type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: don't know how to merge refcounts on objects of type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_jobj_refcnt_merge",
            "prototype": "",
            "backtrace": [
                "_create_or_modify_jobj"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Preventing %s of objects to synthetic folder (id %lld, parent %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "prevent_synthetic_object_operation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_prevent_synthetic_object_operation",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Shadow create_or_modify_jobj(jobj %p id %lld xid %lld op %d) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "duplicate_jobj_op_to_shadow_fs_root",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_duplicate_jobj_op_to_shadow_fs_root",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unknown expanded type (%hhu) on record (%u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to init extended fields on purgeable %llu from blob\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to init extended fields on dir-stats %llu from blob\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_large_key_val_to_jobj",
            "prototype": "",
            "backtrace": [
                "_key_val_to_jobj"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"unknown fext lookup variant %d!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_lookup_file_extent_ext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Trying to delete space for extent %lld %lld which has invalid owning_obj_id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s deleting extent %lld %lld with invalid owning_obj_id %lld while apfs_num_snapshots is 0, this will cause overallocation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_free_data_blocks_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s key @ %p key.hdr.obj_id %lld val @ %p val.kind %d refcnt %d owning_obj_id 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"kind == NEW && refcnt = %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s key.hdr.kind != NEW && numsnapshots == 0\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't insert extent, err=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_insert_phys_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s expanded record found on unsupported volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "jobj_type_from_possibly_large_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_jobj_type_from_possibly_large_key",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->ekwk == ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino->rsrc_ekwk != ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_put_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: er: read data: error while doing strategy on nx dev: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: er: read data: error while waiting for block io to complete: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_read_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to change protection class on default_crypto_id %lld (ret %d, prot_class %d) on ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to convert the default crypto id on ino %lld/%lld (default_crypto_id %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to change protection class on file extent crypto_id %lld (ret %d, prot_class %d) on ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_change_dstream_prot_class",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "jobj->type == APFS_TYPE_FILE_EXTENT",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Sparse extent has non-zero crypto-id!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "%s:%d: %s Unexpected extent with zero crypto-id!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "ino->default_protection_class != 6",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s could not lookup crypto-id %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_crypto_id_converter",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "key != val",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(map->next_index < map->capacity) || (map->capacity == map->max_capacity)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_crypto_id_map_put",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "map->next_index <= map->capacity",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "map->capacity <= map->max_capacity",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_crypto_id_map_assert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"map capacity overflow %lu\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_crypto_id_map_capacity",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s only collected %d crypto state, ino %llu, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to retain crypto-id %llu for ino %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_iterate_ino_crypto_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: iteratively found drec: %s matching ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_remove_purgeable_drec_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__remove_purgeable_drec_cb",
            "prototype": "",
            "backtrace": [
                "_iteratively_remove_purgeable_drec"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: can't mark a directory as purgeable if it has a sub-directory (dir: %lld ; sub-dir ino %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "child_size_calculator_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_child_size_calculator_cb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get ino %lld in dir %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to delete dir entry %lld:%s (file-id %lld) ret=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_child_remover_cb",
            "prototype": "",
            "backtrace": [
                "_fs_delete_inode_with_xid"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d removing purgatory entry %lld/%s for ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s update of the purgatory dir failed! err %d xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_purgatory_entry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove hash file info for id %llu @ logical offset %llu err %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "remove_hash_file_info_record",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_hash_file_info_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove ext %lld:%lld for obj %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to decrement physical range pbn=%llu len=%llu for obj-id %lld (ret %d/%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__remove_extents_of_file_cb",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "recursively_remove_extents_of_dir",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_delete_inode_with_name",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error %d while removing extents on %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_extent_remover_callback",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "get_new_crypto_id_if_needed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_new_crypto_id_if_needed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s bad move stan. extents w/id %lld on ino %lld has a refcnt of %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to restore clone attributes for ino %llu (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"%s:%u: \" \"cannot update ino %llu, %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_clone_extents_adjust_dstream_cryptoid_if_needed",
            "prototype": "",
            "backtrace": [
                "_clone_extents_if_needed_with_gst"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "curr_xid && (curr_xid != ((xid_t)~0ULL))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "clone_iteratively",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "clone_file_fexts",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "new_ino_clonesplit_src",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot deref ino %llu old ekwk %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "commit_ino_clonesplit",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "snk->ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src->fexts.ekwk != snk->ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_clone_file_fexts",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: ino %llu has no ekwk id\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "ino_get_ekwk_uncached",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_ino_get_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot generate new class %u key, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot insert scalable key %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_new_clonesplit_snk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->ekwk == cur_ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_swap_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot deref staged ekwk %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "clonesplit_snk_free",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_clonesplit_snk_free",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove dstream_id %llu (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "remove_dstream_id_and_fexts_copy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove extents of dstream %llu (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_dstream_id_and_fexts_copy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't enter the cleanup transaction... ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't find drec for tmp_ino %llu (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_iteratively_clone_extents_of_file",
            "prototype": "",
            "backtrace": [
                "_clone_extents_if_needed_with_gst"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to clone xattr %lld:%s (source %lld) err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "xattr_cloner",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "!xattr_is_rsrc(xattr)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_xattr_cloner",
            "prototype": "",
            "backtrace": [
                "_clone_xattrs"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "kind == XATTR_KIND_RSRCFORK || kind == XATTR_KIND_DECMPFS",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_xattr_is_kind",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: obj-id %lld is not a dir-rec and should be (type=%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get ino %lld in dir %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s: failed materializing child ino %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clone_children_cb",
            "prototype": "",
            "backtrace": [
                "_fs_obj_clone_name_checked"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unable to prime bitmap for new allocation paddr=0x%llx count=0x%llx, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to look up er_state_obj, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_get_space_for_new_file_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cannot insert file extent record for extent of %lld bytes at offset %lld of data stream %lld in transaction %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_insert_fext_record",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to release reference to crypto ID %lld for data stream %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_insert_fext_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot update extent at offset %lld in inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_update_unwritten_extent_record",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Region of %lld bytes at offset %lld of inode %lld ends before sparse extent at offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Region of %lld bytes at offset %lld of inode %lld starts after sparse extent of %lld bytes at offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Unexpected allocated/unwritten range for %lld bytes at offset %lld in inode %lld inside the sparse extent of %lld bytes at offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_find_gaps_middle_out",
            "prototype": "",
            "backtrace": [
                "_fs_map_file_offset_ext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Requested offset %lld is not inside the sparse file extent %p (%lld, %lld) of inode %lld\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Requested offset %lld is not inside the sparse file extent %p (%lld, %lld) of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Unexpected tier information %d\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Only %lld bytes has been reserved on inode %lld, this is not enough to accomodate %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Not enough blocks had been reserved to account for %lld newly allocated blocks for inode %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Only %lld blocks have been reserved, not enough to account for %lld newly allocated blocks for inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s BUG BUG BUG: ino %lld non-contiguous extents! prev_fext %lld:%lld (%lld) and orig_fext %lld:%lld (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fs_make_hole_range_writable",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "punch out",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Found a gap between range %lld:%lld,%d and offset %lld in the extent %lld:%lld of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_punch_out_ranges_in_fext",
            "prototype": "",
            "backtrace": [
                "_fs_map_file_offset_ext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Range %lld:%lld,%d does not start at the extent boundary %lld:%lld of inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "merge",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_decrement_unwritten_ranges_counters"
                },
                {
                    "string": "convert",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_decrement_reserved_ranges_counters"
                },
                {
                    "string": "split",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Found a gap between %lld and %lld with %lld bytes remaining, fext %p, reserved range %p, list of ranges %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Found a gap between offset %lld and range starting at %lld with %lld bytes remaining in the extent %lld at %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"Extent is larger than the span - %lld bytes left at %lld, fext %p, list of ranges %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Extent %lld at %lld is larger than the reserved region: %lld bytes left at offset %lld in inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_update_reserved_ranges",
            "prototype": "",
            "backtrace": [
                "_fs_map_file_offset_ext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "remove",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_decrement_reserved_ranges_counters"
                }
            ],
            "symbol": "_apfs_drop_reserved_rangelist_entry",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s apfs_update_phys_range failed, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s allocate_phys_range failed, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to restore orig_fext, ino %llu, pbn 0x%llx, laddr 0x%llx, len %llu, crypto_id %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove head_fext, ino %llu, laddr 0x%llx, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to remove tail_fext, ino %llu, laddr 0x%llx, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to increment crypto state refcnt, ino %llu, crypto_id %llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to retain crypto state, ino %llu, crypto_id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to free allocated blocks, ino %llu, 0x%llx+%llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_update_phys_range for satisfiable range failed on 0x%llx+%llu, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_make_phys_range_writable",
            "prototype": "",
            "backtrace": [
                "_fs_map_file_offset_ext"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get a new default crypto-id, ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_fs_add_xattr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"_fs_add_xattr does not support stream-based xattrs in the kernel\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "__fs_add_xattr",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s volume is not sealed, cannot perform extent manipulation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s volume fext tree is not physical, cannot perform extent manipulation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s volume has quota or reserved space, cannot perform extent manipulation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Remapping may have been done across snapshots, cannot perform extent manipulation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_can_manipulate_extents_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s snapshot xid %llu is dataless, cannot perform extent manipulation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_can_manipulate_snapshot_extents_callback",
            "prototype": "",
            "backtrace": [
                "_fs_can_manipulate_snapshots_extents"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Bootcache inodes tree is NULL, cannot ignore boot files\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_dstream_evict_scanner",
            "prototype": "",
            "backtrace": [
                "_fs_evict_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s xattr %lld has 0 dstream_id\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s inode %lld has 0 dstream_id\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream %llu ino %llu iflags 0x%llx (JI_DIRECT_IO_PENDING is set)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream_evict_range %lld failed with ENOSPC\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_dstream_evict_scanner_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s No defrag state for dstream in dstreams tree %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_dstream_should_ignore",
            "prototype": "",
            "backtrace": [
                "_dstream_evict_scanner_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_tx_leave failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "pause-evict-loop",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_dstream_evict_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: extent_evict_range %lld failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Eviction is taking too much time %lld, %d blocks evicted, exit transaction for extent %lld, abs start time %lld, abs time of last extent %lld, blocks evicted till last extent %lld)!!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s volume is not a snapshot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot evict extent in range %llu->%llu as inode is marked immovable\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fext oid %lld laddr %lld paddr %lld, len in blocks %lld has no matching pext, and there are no snapshots!!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s lookup_phys_extent(%lld,%lld) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream %lld, phys_ext %lld has an update record with invalid owning_obj_i, and there are no snapshots!!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream %lld, phys_ext %lld has an update record with invalid owning_obj_i, set extent_in_snapshot to true\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Extent %lld, %lld is trapped in a snapshot, This is not supported for non sealed volume\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s extent_update_range_to_evict failed: %d - %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s bad ranges returned from extent_update_range_to_evict %lld %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Evicted too many blocks, update ext_end and prange\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Evicting extent %lld %lld with invalid owning_obj_id %lld while apfs_num_snapshots is 0, this will cause overallocation\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s evict_map_range failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fext_collector failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s extent begins before blocked out range, no need to add a new physical extent\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s extent ends after blocked out range, need to increase ref count for the physical range outside the blocked out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to increment the physical extent refcount on %lld:%lld ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to increment the crypto state refcount for crypto_id %lld, ret %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to insert logical extent for dstream %lld @ logical offset %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Evicting a graft ino!!!!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to insert extent (%lld)->(%lld, %lld) from blockmap lut, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_extent_evict_scanner",
            "prototype": "",
            "backtrace": [
                "_dstream_evict_range"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Not a pure overlap %lld, %lld to range %lld, %lld, in newer xid (%lld > %lld) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_extent_update_range_to_evict",
            "prototype": "",
            "backtrace": [
                "_extent_evict_scanner",
                "_dstream_evict_range"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dstream Ids do not match %lld != %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dstream %lld pext tree is NULL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_dstream_pext_tree_lookup_overlap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error allocating %d bytes for data copy\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman_alloc failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Mapping (%lld,%lld) allocated outside the soft block-out range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Extent %lld, %lld allocated inside the soft block-out range %lld, %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Data could not be copied from original extent to new extent, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cancellation requested - stopping evict\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to insert new physical extent addr %lld, len %lld, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_evict_map_range",
            "prototype": "",
            "backtrace": [
                "_extent_evict_scanner",
                "_dstream_evict_range"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s reference_phys_range failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reference_phys_range_in_snap failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to delete zero ref tree, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "zero_ref_tree_create",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_extent_refcount_fix",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to remove the physical extent @ %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to free space %lld, %lld (ret %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clear_zero_ref_mappings",
            "prototype": "",
            "backtrace": [
                "_extent_evict_scanner",
                "_dstream_evict_range"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "fs_evict_range_snapshot_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_evict_range_snapshot_callback",
            "prototype": "",
            "backtrace": [
                "_fs_evict_range",
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dstream_id %lld, is_xattr %d has changed in inode, will not promote",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fs_verify_dstream_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_promote_dstream",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "fs_promote_dstream_snapshot_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_promote_dstream_snapshot_callback",
            "prototype": "",
            "backtrace": [
                "_nx_promote_to_soft_block_out_range",
                "_nx_defrag_hdd_boot_files",
                "_handle_bc_optimize_inodes",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: extent(%lld) %lld, %lld is not completely in soft block out range %lld, %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "extent_verify_in_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_extent_verify_in_range",
            "prototype": "",
            "backtrace": [
                "_nx_verify_bootcache_defrag",
                "_nx_defrag_hdd_boot_files",
                "_handle_bc_optimize_inodes",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s ignoring ino %lld added AFTER directory was flagged!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to flag ino %lld as maintain-dir-stats (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error looking up dstats %llu for ino %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to update dir size key %lld for ino %lld (err %d) (descendants %llu physical_size %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__setup_dstats_cb",
            "prototype": "",
            "backtrace": [
                "_do_setup_dir_size"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to fetch ino %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "_get_dstats_cb",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__get_dstats_cb",
            "prototype": "",
            "backtrace": [
                "_get_dir_size"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to compare currently available space: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %s: ENOSPC: ttype %s num_blocks %lld free_blocks %lld blocks_in_txn %lld num_records %lld num_data_blocks %lld num_active_txns %d (reserved ranges total blocks: %lld) current xid: %lld threshold_blocks %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s tx_enter_frozen() failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fs_tx_enter_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s purge of object %lld throttled\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to delete ino %lld (%s) iflags 0x%llx err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s remove_purgatory_entry failed on %s for file-id %lld err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_purgatory_cleaner_cb",
            "prototype": "",
            "backtrace": [
                "_apfs_cleanup_purgatory_continuation"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fixing doc-id index on volume: %s, starting from obj-id %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s stop background work requested, stopping doc-id fixup\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s processed %8lld records, fixed %lld doc-id records\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to insert doc-id mapping for %d (ino %lld) : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to start txn to insert doc-id mapping for %d (ino %lld) : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_iterator_next failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to enter tx on doc-id fixup completion, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s doc-id fixup failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fixup_thread_wrapper",
            "prototype": "",
            "backtrace": [
                "_start_fixup_thread_if_needed"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't enter TX on mount for demo mode: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't create extentref tree for demo mode: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_setup_demo_mode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs_alloc_count mismatch: fs root nodes %lld extent %lld omap %lld snap_meta %lld doc_id %lld prev_doc_id %lld fext: %lld pfkur: %lld er: %lld udata: %lld fs_alloc_count %lld != count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "sanity_check_alloced_blocks",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_sanity_check_alloced_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s set cloneinfo_id_epoch to %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s couldn't enter transaction to set apfs_cloneinfo_id_epoch, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_set_cloneinfo_id_epoch",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s restarting fixup hardlink scan from obj-id %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Fixing hard links on volume: %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Processed %8lld records. Fixed %lld hard links\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to insert sibling map for %lld (ino %lld) : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to start txn to insert sibling map for %lld (ino %lld) : err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fixup_hardlinks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot get ino %llu ekwk %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot get ino %llu ek %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cannot unwrap ino %llu ek %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_cp_get_ek2",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "ino->rsrc_ekwk == ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ino->ekwk != ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_ino_put_rsrc_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "jobj_id_is_valid(id)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "mcp_is_class_id(id)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_make_scalable_lookup_key",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s was NOT able to update/decrement crypto state %lld, err = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s danger - crypto id %lld had refcnt %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_icp_dec_ref",
            "prototype": "",
            "backtrace": [
                "_cp_dec_ref"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "*xid && (*xid != ((xid_t)~0ULL))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to decrement refcnt on crypto-id %lld on behalf of ino %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to dereference blocks, pbn:%llu len:%llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to remove extent %lld %lld:%lld (ret %d) \n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_clone_fexts_",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot free fext %llu %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "clone_split_fext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: cannot revert pext references %llu, %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "clone_fext_resources",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "state->src->ekwk && state->snk->ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "old_id != new_id",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"%s:%u: \" \"cannot unwrap ek %llu, %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"%s:%u: \" \"cannot rewrap ek %llu, %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: cannot insert new ek, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "mcp_clone_ek_uncached",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "skey_has_ek(ek)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s cannot deref pexts %llu, %llu:+%llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "free_fext_resources",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cannot deref crypto id %llu, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_clone_split_fext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "src->phys_block_num",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!(src->flags & FEXT_CRYPTO_ID_IS_TWEAK)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_icp_clone_ek",
            "prototype": "",
            "backtrace": [
                "_clone_split_fext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "state->xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src_class == snk_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "src_ino->default_protection_class == snk_ino->default_protection_class",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s failed to increment the crypto state refcount (crypto_id %lld) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to increment physical range (pbn %llu) (len %llu) (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to retain crypto state %lld (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_sr_insert_fexts",
            "prototype": "",
            "backtrace": [
                "_handle_share_range",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%ss%d:%lld",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                }
            ],
            "symbol": "_apfs_update_dev_name",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get omap %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap checkpoint traverse (op %d) failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_checkpoint_traverse",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: System is shutting down stop any bg work\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Volume %s is unmounting, stop any bg work\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_stop_bg_work",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get er state object, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_is_encryption_rolling_pending",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_is_encryption_rolling_pending",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Volume role 0x%x can be assigned only at the time of volume creation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_getset_role",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient16methodVolumeRoleEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "apfs_get_with_uuid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_meta_crypto_state_unwrap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "apfs_get_with_role",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_get_with_role",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s adjusting cow exempt count from %lld to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s COW exempt file count underflow: %lld (delta %lld).  capping to zero.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to add initial cow-exempt-count xattr! err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s added initial cow-exempt-count xattr!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s failed with err %d while getting the cow-exempt-file-count xattr on the root dir\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_update_cow_exempt_file_count",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_sanity_check_tree_type",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "_apfs_sanity_check_tree_type",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s bogus phase, %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to modify the apfs_t before reaping (error %d).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freed != alloced (%llu freed, %llu alloced)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s supplemental_tree_destroy(fext_tree) failed: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s supplemental_tree_destroy(pfkur_tree) failed: %d (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap_destroy returned %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s apfs_meta_crypto_state_destroy returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_reap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Hit %d looking up first snapshot\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't find snapshot metadata for xid %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s lookup_next_snapshot() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_reap_snapshots",
            "prototype": "",
            "backtrace": [
                "_apfs_reap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: apfs_get_extentref_tree(oid=%llu) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_iter_init() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s extent at lba %llu len %llu couldn't be freed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_free_data_blocks"
                },
                {
                    "string": "%s:%d: %s found bogus 0-length extent at lba %llu, ignoring\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s iter_next returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_reap_extentref_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get fsroot tree, in_graft %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to initialize iterator, in_graft %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_graft_host_iterator_switch",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "Product Name",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "Vendor Name",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                },
                {
                    "string": "Product Revision Level",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN15OSMetaClassBase12safeMetaCastEPKS_PK11OSMetaClass"
                }
            ],
            "symbol": "__ZN18APFS_AA_DeviceInfo4initEP7IOMedia",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.apfs.hash_violation.compressed_dstream_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc"
                }
            ],
            "symbol": "_apfs_report_hv_compr_data_bad_hash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: Failed to cast CoreAnalyticsHub\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "attachCoreAnalyticsService",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL26attachCoreAnalyticsServicePvS_P9IOServiceP10IONotifier",
            "prototype": "",
            "backtrace": [
                "_apfs_module_start"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "Main_IcType",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Main_IcLocation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Main_MediumType",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Main_Product",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Main_Vendor",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Main_Rev",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_IcType",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_IcLocation",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_MediumType",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_Product",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_Vendor",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                },
                {
                    "string": "Tier2_Rev",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "__ZN12_GLOBAL__N_113add_parameterIP8OSStringEEbR11OSSharedPtrI12OSDictionaryEPKcRKT_"
                }
            ],
            "symbol": "__ZL17add_common_fieldsR11OSSharedPtrI12OSDictionaryEPK2nx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: CoreAnalytics service is not initialized, cannot send event [%s]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to send event [%s] to CoreAnalytics\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN12_GLOBAL__N_119apfs_analytics_sendER11OSSharedPtrI12OSDictionaryEPKc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s node 0x%llx (level %d): error getting index %d child oid: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s node 0x%llx (level %d) index %d: more levels than expected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s node 0x%llx (level %d): error getting index %d child: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s node 0x%llx (level %d): error getting index %d key/val: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_check_recent_sanity",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get wbc list head: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_get_head",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot get WBC instance: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Preferred buffer size for Fusion WBC elevator is too large, clamping down to %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Unable to allocate %llu bytes for Fusion elevator buffer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "wbc-elevator-wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Fusion Elevator of %s failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion_mt_elevator_get_dirty_extent(0x%llx, %llu) failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_elevator_force_elevate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Cannot remove middle-tree entry for extent %lld @ %lld (mapped to %lld): %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_forced_elevator_unmap_extents",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Cannot remove middle-tree entry for extent %lld @ %lld (mapped to %lld): %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Critical: Elevator has failed to unmap a MT entry for extent %lld @ %lld (mapped to %lld): %s (%d), Making read-only\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_elevator_finish_head",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_elevator_thread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Extent length is zero\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_read_inflight",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion_wbc_read_inflight failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion_mt_read_extent failed with %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_remap_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Fusion is started in %s mode\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "fusion_wbc_startup",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "regular",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Main tier media is %s, Tier2 media is %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ERROR: Fusion tiers configuration is incorrect\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WARNING: Fusion tiers configuration could be incorrect\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_fusion_wbc_startup",
            "prototype": "",
            "backtrace": [
                "_nx_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Fusion: ambiguous stashed RC range values: 0x%llx, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Fusion: deallocating stashed RC range: 0x%llx, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s obj_modify(wbc) failed: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_clear_stash",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to resume WBC elevator: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "fusion_wbc_force_elevator_request",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_fusion_wbc_force_elevator_request",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"File a radar against APFS Fusion: Cannot find active inflight %s IO for %sLBA %llx, length %u, cookie: %p.\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_wbc_complete_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"wbc->phys->fwp_usedByRC >= wbc->phys->fwp_dirtyInRC\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s CORRUPTION: RC total %llu < RC Dirty %llu !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_rc_get_evictable_count",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_rc_get_evictable_count",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"wbc->phys->fwp_usedByRC >= -delta\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: CORRUPTION: RC used counter %llu%lld < 0!!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"wbc->phys->fwp_dirtyInRC <= wbc->phys->fwp_usedByRC\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_rc_update_alloc_accounting",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fusion_rc_update_dirty_accounting",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_rc_update_dirty_accounting",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Cannot stash, the slot is occupied by [0x%llx, %llu]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_rc_stash_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_rc_stash_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Removing MT range %llx, %llu, failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_remove_range_deallocate_rc(%llx, %llu, clean) failed with %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error adding range to wbc: %llx -> %llx, %llu %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error incrementing RC dirty count %llx -> %llx, %llu %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"encryption rolling: ext_off 0x%llx > extent_len 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s error preparing extent for roll, lba 0x%llx, mappedLba 0x%llx, length 0x%llx, isTenant %d, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_fusion_prepare_roll_extents",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to get MT tree when removing range %llx, %llu on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to remove a MT range %llx, %llu on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_fusion_prepare_roll_extents",
            "prototype": "",
            "backtrace": [
                "_er_roll_window"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Incorrect WBC instance object version: %llu while %lu was expected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WBC instance object corrupted: stableHeadOffset(%llu) > stableTailOffset(%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WBC instance object corrupted: distance between stableHeadOffset(%llu) and stableTailOffset(%llu) is bigger than WBC cache size: %llu > %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: WBC instance object corrupted: number of WBC list objects is larger than WBC cache size: %u > %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WBC instance object corrupted: listHeadOid(0x%llx) is not in the WBC area (0x%llx, %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WBC instance object corrupted: listTailOid(0x%llx) is not in the WBC area (0x%llx, %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s WBC instance object corrupted: listTailOid == listHeadOid(0x%llx) but the number of list objects(%u) is not 1\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Incorrect WBC List object version: %llu while %lu was expected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Incorrect WBC List object @ 0x%llx: indexBegin(%u) > indexEnd(%u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Incorrect WBC List object @ 0x%llx: indexEnd(%u) > indexMax(%u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Incorrect WBC List object @ 0x%llx, entry# %u: incorrect length (%llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_list_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "\"NX SB: Fusion WBC OID is invalid. Please file a bug against APFS Fusion\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"fusion_wbc_get is unexpectedly called on Non-Fusion configuration\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s Fusion WBC obj_get(%llu) failed with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_get",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_get",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to create new wbc list: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get wbc list tail: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s an empty WBCL block has been left behind\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to create new wbc list entry: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_get_list_tail",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s obj_modify(wbc,%llu) failed: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_wbc_pop_head",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_wbc_pop_head",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s WBC trim failed in for (0x%llx, %llu) with %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_trim_wbc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_trim_wbc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Consider %s thread of container %s dead",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fusion_wbc_thread_shutdown",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fusion_wbc_thread_shutdown",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "\"Bogus argument for callback on buffer %p\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"Cannot find buffer %p in context %p\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_wbc_elevator_io_callback",
            "prototype": "",
            "backtrace": [
                "_fusion_wbc_elevator_alloc_buf"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "WBC Elevator wait for read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_elevator_issue_io"
                },
                {
                    "string": "WBC Elevator wait for write",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_fusion_wbc_elevator_issue_io"
                }
            ],
            "symbol": "_fusion_wbc_elevate_extents",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fusion_inflight_flush_thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_rw_lock_shared"
                },
                {
                    "string": "%s:%d: %s Failed to create MT mapping for LBA %llx -> %llx, size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to remove MT mapping for LBA %llx, size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_rw_lock_shared"
                },
                {
                    "string": "inflight-flusher-wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_fusion_inflight_flush_thread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Cannot trim region (0x%llx, %llu) of container %s: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_trim_range",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_trim_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d Failed to find successor node in length tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_free_extent_cache_insert",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_free_extent_cache_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d Failed to delete covered node from length tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_spaceman_fxc_tree_delete_at_path"
                },
                {
                    "string": "%s:%d: %s dev %d Failed to get next extent: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dev %d Failed to update partially-covered node in length tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_free_extent_cache_remove",
            "prototype": "",
            "backtrace": [
                "_spaceman_alloc"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d size %lld table %d/%d blocks %lld %lld:%lld:%lld range %lld:%lld %d.%02d%%\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "spaceman_fxc_print_stats",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_spaceman_fxc_tree_last"
                },
                {
                    "string": "%s:%d: %s dev %d dropped[%d]: %lld blocks %lld %lld:%lld:%lld range %lld:%lld %d.%02d%%\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_spaceman_fxc_tree_last"
                },
                {
                    "string": "%s:%d: %s *** scanning free blocks returned: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s *** error trim'ing free blocks: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_mount_trim_thread",
            "prototype": "",
            "backtrace": [
                "_nx_mount_initiate_free_space_trims"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d %s tree: PATH TOO LONG: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_fxtp_add_child",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fxtp_add_child",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d Failed to find smallest extent in paddr tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dev %d Failed to find smallest extent %d in length tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dev %d Failed to find next smallest extent in length tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fxc_tree_node_recycle_smallest_if_full",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d length tree search for 0x%llx 0x%llx returned node %d instead of %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_fxc_update_length",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fxc_update_length",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dev %d Failed to find successor node from length tree while updating smallest: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_fxc_update_smallest_with_successor",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fxc_update_smallest_with_successor",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s %s GRAFT (compiled @ %s %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "graft_dev_init",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s GRAFT (compiled @ %s %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %s device_handle block size %d real block size %d block count %lld features %d %s %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s device_handle block size %d real block size %d block count %lld features %d %s %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s checkpoint superblock %d @ %lld: failed sanity check: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld checkpoint superblock index %d doesn't match index block was found at: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld checkpoint superblock index %d doesn't fit in blocks remaining: %d > %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld validation failed for checkpoint at index %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld data for checkpoint at index %d couldn't be loaded: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to fix up checkpoint data: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld sanity check of recently-changed structures failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to get spaceman: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to load spaceman metadata ranges (overlap?): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s warning: best valid checkpoint xid %lld is less than max free queue oldest xid %lld seen in checkpoint %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: graft device initialization failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s container block size too small for device block size (%d < %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s block size %d is not an even multiple of device block size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't read superblock of size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s superblock block size %d not an even multiple of device block size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s superblock container size %lld greater than device size(s) %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s superblock failed sanity checks: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't read tier2 device superblock of size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tier2 device superblock doesn't agree with main superblock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: conflicting mount options: load from temporary checkpoint AND checkpoint descriptor index %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: conflicting mount options: is_system_graft but not is_graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: graft with invalid fs block size: %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "hw.memsize",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_sysctlbyname"
                },
                {
                    "string": "%s:%d: could not get memsize.  defaulting to 512 megs.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_obj_cache_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: Object cache override not a multiple of 1024\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Object cache override %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s initializing cache w/hash_size %u and cache size %u\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s object cache initialization failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s object cache bootstrap failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s setting nx device flag NX_BACKINGSTORE_IS_SPARSE\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s fragmented checkpoint area failed sanity check: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to allocate buffer for checkpoint superblock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s storage is untrusted. Container cleanly-unmounted flag ignored\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint descriptor length is bad.  Container cleanly-unmounted flag ignored\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint data length is bad.  Container cleanly-unmounted flag ignored\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s container cleanly-unmounted flag set.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s Attempting to load from temporary checkpoint (start xid %lld).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s No temporary checkpoint start xid!  Aborting!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to scan checkpoint descriptor area for largest xid: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint descriptor index %d out of range [0...%d]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Attempt to load temporary checkpoint found unexpected data (0x%02x @ %d), checkpoint descriptor block %d @ %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint descriptor block %d is not a valid superblock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint descriptor block %d superblock failed sanity checks: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint descriptor block %d doesn't agree with main superblock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint superblock index %d doesn't match index block was found at: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s validation failed for checkpoint at index %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint: largest xid %lld, given checkpoint xid %lld @ %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s loading older checkpoint, checkpoint xid %lld, superblock xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s data for checkpoint at index %d couldn't be loaded: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to fix up checkpoint data: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sanity check of recently-changed structures failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint xid %lld failed to get spaceman: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint xid %lld failed to load spaceman metadata ranges (overlap?): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Couldn't load checkpoint from cleanly-unmounted state.  Falling back to descriptor scan.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to find valid checkpoint: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint search: largest xid %lld, best xid %lld @ %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s reloading after unclean unmount, checkpoint xid %lld, superblock xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unsupported nx_readonly_compatible_features (0x%llx): mount r/o\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s hibernate-lock mount, mount r/o\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s stable checkpoint indices: desc %d data %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s failed to set up spaceman for demo mode: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx manager initialization failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to initialize Fusion inflight instance object: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to start Fusion IO completion thread: %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to retrieve the Fusion WBC instance object: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_unblock_physical_range failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_mount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: tree_insert %u->(%lld, %u) returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_remove_mapping_in_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Host volume is graft\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to create blockmap lut tree, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s graft_blockmap_lut_release failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "graft_blockmap_lut_tree_create",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s clone the blockmap lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: clone the blockmap lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to allocate memory for the blockmap lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to copy blockmap lut tree, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_clone",
            "prototype": "",
            "backtrace": [
                "_clone_extents_if_needed_with_gst"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: reference count dropped to 0, free blockmap_lut\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "graft_blockmap_lut_release",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: failed to delete blockmap lut tree, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_release",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"blockmap lut not initialized\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "io_graft.c",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: failed to get graft vp: error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s blockmap lut lookup(%llu, %zu) failed, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: blockmap lut lookup(%llu, %zu) failed, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_remap_read(%lld, %lld) failed, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to perform read: graft(off: %llu, byte len: %zu) host(block: %llu, block len %llu) - error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to perform read: graft(off: %llu, byte len: %zu) host(block: %llu, block len %llu) - error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_dev_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: range below (%u, %u) overlaps with range inserted (%llu, %llu)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: host range below (%llu, %llu) overlaps with range inserted (%llu, %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: range above (%llu, %llu) overlaps with range inserted (%u, %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: host range above (%llu, %llu) overlaps with range inserted (%llu, %u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_tree_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Graft file has holes in it (%lld, %lld), block size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to insert %llu->(%llu, %llu) into the blockmap lut, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_graft_blockmap_lut_data_extents_cb",
            "prototype": "",
            "backtrace": [
                "_graft_blockmap_lut_create"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: pageout on the fake mount...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_fake_vnop_pageout",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fake_vnop_pageout",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to vnode_create the vnode for %lld!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fake_load_inode",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fake_vnop_lookup",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: can't read from unknown ino num %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_fake_vnop_read",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_fake_vnop_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: unaligned write (offset=%lld size=%lld bsize=%d, ino=%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: writing to HFS @ %lld for %lld bytes... (filesize %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: writing to NX @ %lld for %lld bytes... (filesize %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: can't write to unknown ino num %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_fake_vnop_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_fake_vnop_readdir",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fake_vnop_readdir",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Decorating bp with the crypto state for HFS...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: cpoffset %lld set container offset %lld to 0\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Unknown inode %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_fake_vnop_strategy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Adjusting nx keylocker start_paddr %lld with container offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "apfs_fake_vnop_ioctl",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Adjusting apfs keylocker start_paddr %lld with container offset %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_fake_vnop_ioctl",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to get fsroot tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to get fsroot tree count: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_handle_get_fsinfo",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to construct search object, unexpected type %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fsinfo_construct_search_obj",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_fsinfo_iterate_fsroot",
            "prototype": "",
            "backtrace": [
                "_handle_get_fsinfo",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_fsinfo",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tsleep"
                }
            ],
            "symbol": "_apfs_fsinfo_iterate_fsroot_wrapper",
            "prototype": "",
            "backtrace": [
                "_apfs_fsinfo_iterate_fsroot",
                "_handle_get_fsinfo",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "btree_node_child_val",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_btree_node_child_val",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s minkey update traversal unexpectedly found the key (%d) or a non-zero index (%d); oid %llu subtype 0x%x level %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_bt_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"you can't change a key here!  (ekey %p eklen %d; key %p klen %d; n %p bt %p)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_bt_update_with_hint",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s minkey update traversal unexpectedly found the removed key in level 1 node; oid %llu subtype 0x%x level %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_bt_remove_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error getting index %d child oid: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx index %d: more levels than expected\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error getting index %d child 0x%llx flags 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error prefetching index %d child 0x%llx flags 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error ON WAIT getting index %d child 0x%llx flags 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error MODIFYING index %d child 0x%llx flags 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s level %d node 0x%llx: error getting index %d child flags 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_iterate_nodes",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s btree_node_insert_internal failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_node_child_val"
                }
            ],
            "symbol": "_btree_node_copy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error adding btree 0x%llx type 0x%x to reap list: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "btree_delete",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_delete",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s btree_evict_range called on non-physical tree oid: %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s btree_evict_range called on non-physical tree oid: unknown, paddr %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s btree_node_child_val() failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s cancelling eviction of btree elements\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s btree_node_get failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"btree_node_child_id_update failed with error: %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_btree_evict_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error getting oid for child %d of 0x%llx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_btree_node_child_val"
                },
                {
                    "string": "%s:%d: %s error adding child 0x%llx type 0x%x to reap list: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error deleting child 0x%llx type 0x%x: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_node_reap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "btree_node_key_range_validate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_btree_node_key_range_validate",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "btree_node_val_range_validate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_btree_node_val_range_validate",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get newnode minkey: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reverting on error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s btree_node_insert() failed (%d) while trying to revert changes due to error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_bt_shift_or_split",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s obj_exchange_phys (%llx, %llx) with xid %llu failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "btree_node_compact",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_node_compact",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to reclaim just-freed key space on error path: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to reclaim just-freed val space on error path: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_btree_node_entry_update",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "btree_node_free_list_entry_validate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_btree_node_space_free_list_search",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s updating grandparent failed w/%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_bt_merge_up",
            "prototype": "",
            "backtrace": [
                "_bt_remove_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to move all entries: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_bt_merge_nodes",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "bt_lookup_copy_out",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_bt_lookup_copy_out",
            "prototype": "",
            "backtrace": [
                "__bt_lookup_variant"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid KEK length\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fileVault service is not configured\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unexpected blob length\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get KEK blob size\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unexpected KEK blob length\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to get VEK blob size\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unexpected VEK blob length\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to create apfs volume keybag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: nx_keybag_import failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: cpx is NULL after nx_keybag_import !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to allocate VEK data after nx_keybag_import !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to copy VEK data after nx_keybag_import !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to allocate KEK data after nx_keybag_import !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: failed to copy KEK data after nx_keybag_import !!!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to set VEK/KEK in apfs volume keybag, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: apfs_keybag is NULL in non-first init call\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to set KEK in apfs volume keybag, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to create apfs volume keybag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to create KEK/VEK in apfs volume keybag (%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s created apfs volume KEK/VEK\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_apfs_meta_crypto_state_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "com.apple.keystore.lockassertion.time_machine",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_apfs_is_task_entitled_to"
                }
            ],
            "symbol": "_is_tmassert_passthrough_allowed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS check_class failed with unexpected error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_crypto_check_class_availabilty",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_crypto_check_class_availabilty",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d getting erso after locking physical range\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_erso_lock_phys_range_for_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error entering TX duing state recovery: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error modifying apfs during state recovery: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error modifying state object during state recovery: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to write out recovered data. %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error while updating bitmap for recovered data: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d when deleting recovery data\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_encryption_rolling_write_out_recovered_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error modifying bitmap range: %d (bitmap_start_addr 0x%llx count 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_update_blockmap_with_xid_modified",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_update_blockmap_with_xid_modified",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not modify apfs for bitmap update: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not modify er state object for bitmap update: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not update blockmap, start_addr 0x%llx, count 0x%llx: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_update_blockmap_with_xid",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "gbitmap_flush_queue",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er-gbitmap-flush",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "er-gbitmap-flush-terminate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                }
            ],
            "symbol": "_gbitmap_flush_queue",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s called for snapshot, skipping\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "gbitmap_update_thread_terminate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_gbitmap_update_thread_terminate",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error updating blockmap from the completion thread: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error updating blockmap from the completion thread: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_wakeup"
                }
            ],
            "symbol": "_gbitmap_update_thread",
            "prototype": "",
            "backtrace": [
                "_spawn_gbitmap_update_thread"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s start requested for %s.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "start_encryption_rolling_thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "resume",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s called for snapshot -> EINVAL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Unable to get er_state_obj, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Encryption rolling already in progress (did you mean 'resume'?).\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Container-wide extent manipulation is in progress, cannot start er thread\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s encryption_rolling_thread already running?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Start already requested -- waiting for it to finish.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er-already-started-req",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Thread failed to start by someone else.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Thread successfully started by someone else.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Unable to start encryption rolling thread, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Waiting for thread to start.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er-start-req",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Thread failed to start.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Thread successfully started.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_start_encryption_rolling_thread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Trying to pause er on snapshot. EINVAL.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Failed to got er state object: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failure to update pause flag: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ER state is ok, we patched it.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s ER state is ok, no thread and we are paused.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Requesting thread to pause.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Someone has already requested thread to pause.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Waiting for thread to exit.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er-pause-request",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Thread exited successfully.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_pause_encryption_rolling_thread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s We are going over 100%%, capping at 99%%: %llu[%llu, %llu]",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "query_encryption_rolling_state",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s er:query: returning following: %llu, %llu[%llu, %llu], %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_query_encryption_rolling_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_encryption_rolling_optin",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: %s Encryption rolling operations are not allowed while there are grafts.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s ER not permitted for volume role: 0x%x",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: handle er: unknown cmd: %llu",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZN19AppleAPFSUserClient27methodVolumeCryptoOperationEPS_PvP25IOExternalMethodArguments",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: AKS rewrap_key failed for class = %d, error = %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_rewrap_key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_crypto_state_rewrap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s er: rolling: could not start kernel thread for gbitmap update\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spawn_gbitmap_update_thread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spawn_gbitmap_update_thread",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error entering transaction during er state object update: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error modifying er state object during er state object update: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: update object: er_state_obj oid: 0x%llx, 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error while leaving transaction during er state object update: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_encryption_rolling_update_state_object",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: io filter called as completion handler, should not be happening",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "er_buf_io_filter",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_er_buf_io_filter",
            "prototype": "",
            "backtrace": [
                "_er_write_rolled_data"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Could not enter TX to modify bitmap: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error leaving tx while updating bitmap. %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_update_blockmap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: er: spawn: thread already exists for encryption rolling.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Could not start kernel thread for encryption rolling.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spawn_encryption_rolling_thread",
            "prototype": "",
            "backtrace": [
                "_start_encryption_rolling_thread"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s er init failed, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: resume rolling: Unable to allocate rolling buffers: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: resume rolling: Unable to get bitmap: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: resume rolling: er_state_obj ref: %llu, blockmap ref: %llu.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: resume rolling: Failed to write out recovered state: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to update PAUSED flags: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to set tidemark obj_id: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap rolling failed, error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Retrying omap rolling in 1 sec (retry %d out of %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er-omap-error",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s MARKING VOLUME '%s' FAILED DUE TO ERROR %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s UNABLE TO MARK VOLUME '%s' AS ER-FAILED: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error saving paused flag, %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: rolling: excruciation is over early, during or after metadata encrypt.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: rolling: skipping omap roll.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error rolling live FS data: %d -- exiting.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Pause requsted while rolling live FS data.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: rolling: we are not paused, clean the state for snapshots",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error entering transaction after encrypting live fs data: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er-tx-enter-error",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Error modifying apfs object after live fs encrypt:%x.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er-gbitmap-get-error",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s Error marking er state obj for modify after encrypting live fs data: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er-obj_modify-error",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s error leaving transaction after encrypt live fs: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s er: rolling: skipping live fs rolling.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error rolling snapshot data: %d -- exiting.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Pause requsted while rolling snapshot data.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: rolling: skipping snapshots rolling.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Unable to create transaction to remove ONEKEY crypto state object, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to remove ONEKEY crypto state object, error = %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error while finishing encryption rolling: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: excruciation is over.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: thread is exiting.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"encryption_rolling_thread failed to terminate\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s er: pausing rolling: er_state_obj current obj_id: %llu ref count: %llu blockmap ref count: %llu.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: rolling: ignoring error (%d) while leaving tx during er state obj creation for volume group\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: er: get bitmap: blockmap's oid: 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "er_state_get_blockmap",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: part2: live filesystem: start at fext: 0x%llx:0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "encrypt_live_fs_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: live fs iteration done, roll remaining collected extents\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: reseting throttle window.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: restarting at fext: 0x%llx:0x%llx [%u].\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: part2: live filesystem: stop: progress %llu out of %llu blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: part3: snapshots: start with snap_xid 0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "encrypt_snapshots_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: looking for next non-dataless snapshot after 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_memset"
                },
                {
                    "string": "%s:%d: er: No more snapshots to roll!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: find_next_snapshot returned error %d, aborting!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: er: Rolling snapshot 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_memset"
                },
                {
                    "string": "%s:%d: er: snapshot 0x%llx iteration done, roll remaining collected extents\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: need to try again starting at fext: 0x%llx:0x%llx.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: er: paused while rolling snap_xid 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Could not start transaction to update ER snap_xid, error: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Could not modify apfs when updating ER snap_xid, error: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Could not mod-alloc erso_phys when updating ER snap_xid, error %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Error leaving transction updating ER snap_xid, error %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: er: part3: snapshots: stop.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: finish: could not enter tx with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: finish: failed to remove volume unlock record, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: finish: failed to remove volume key, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: finish: failed to remove volume locker, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: finish could not modify apfs_t %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: finish: cleared apfs_er_state_oid: 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s er: finish: tx_leave returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s request to encrypt while already doing different conversion: om_flags 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s request to decrypt while already doing different conversion: om_flags 0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get omap tree key count: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tree_lookup_ge() failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap_obj_modify(): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s convert op %d, oid %lld xid %lld, ov flags 0x%x paddr 0x%llx current object: flags 0x%llx 0x%x paddr 0x%llx, waiting on write\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error converting oid %lld xid %lld, omap lookup latest returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s convert op %d, oid %lld xid %lld, ov flags 0x%x paddr 0x%llx current object: flags 0x%llx 0x%x paddr 0x%llx, needs rewriting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error converting oid %lld xid %lld, omap_set() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s convert op %d, oid %lld xid %lld, ov flags 0x%x paddr 0x%llx current object: flags 0x%llx 0x%x paddr 0x%llx -> 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_encryption_rolling_thread",
            "prototype": "",
            "backtrace": [
                "_spawn_encryption_rolling_thread",
                "_start_encryption_rolling_thread"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s r: persisted tidemark obj_id is 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error preparing er state object for modify: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: tidemark obj_id set to 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_er_set_tidemark_obj_id",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error modifying apfs object:%x.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error marking er state obj for modify: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_prepare_state_obj_modify",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error setting extended tidemark, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s With obj_id 0x%llx, we have passed the initial tidemark of 0x%llx. Setting extended tidemark to 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s With obj_id 0x%llx, we have passed the extended tidemark of 0x%llx - all done!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s _get_inode_with_lookaside failed?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to start transaction to update dstream default_crypto_id, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s _get_inode_with_lookaside for xattr 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d getting xattr for ino 0x%llx, name [%s]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to start transaction to update xattr dstream default_crypto_id, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_handle_fext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: error %d when rolling window with intersecting fext, fext 0x%llx, laddr 0x%llx, pbn 0x%llx, len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: error %d updating rolled fext on skip\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: error collecting chunk %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: could not enter tx for updating cursor, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: error %d preparing erso for modify\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: failed to leave tx while updating cursor: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: extent roll error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: error %d updating rolled fext\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: failed to leave tx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: throttle: return sleep count: %d, restarting.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "\"encryption rolling: invalid extent window add order: last dstream 0x%llx, fext dstream 0x%llx, num_extents 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"encryption rolling: invalid extent window add order: dstream 0x%llx, last extent laddr 0x%llx, fext laddr 0x%llx, num_extents 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s roll buffer full\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s past end of extent\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fsroot error checking blockmap range: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"encryption rolling, erso_num_extents 0x%llx, erso_encryption_chunk_block_count 0x%llx\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_er_fs_root_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"ER: failed to lock phys range: [0x%llx - 0x%llx]\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_er_lock_fext_phys_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error %d updating rolled fext: obj_id 0x%llx, logical_addr 0x%llx, len 0x%llx, pbn 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_update_rolled_fext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Error updating file extent. %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_update_fext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"encrypting but volume is not onekey\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"decrypting but volume is not onekey\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"not encrypting or decrypting\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_er_get_fext_crypto_info",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s er: fext: could not enter tx while rolling extents, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s fusion locked extents failed verification, restarting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error verifying locked fusion extents, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error preparing fusion extents for rolling, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d during pre-roll\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s FAILED TO WRITE ROLLED DATA AFTER %d TRIES ON VOLUME '%s'\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Could not enter tx while rolling extents[%d].\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d during post-roll\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error leaving TX after roll finish error: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error leaving TX after obj_modify error: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d deleting recovery after rolling\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error leaving TX after delete recovery error: %d.\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fext: return with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error getting extent mappings, idx 0x%llx, pbn 0x%llx, len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"er: number of fusion mappings 0x%llx exceeded 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s er: error checking blockmap range: %d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: bitmap changed while physical range was unlocked, idx 0x%llx, pbn 0x%llx, len 0x%llx, is_already_rolled %d, run_bcount 0x%llx, restarting\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s unable to enqueue request for wbc force flush, idx 0x%llx, pbn 0%llx, len 0x%llx, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s force wbc flush failed, idx 0x%llx, pbn 0x%llx, len 0x%llx, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error searching for dirty extent, idx 0x%llx, pbn 0x%llx, len 0x%llx, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to resume elevator while waiting for it to respond to a block request\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error updating fext for encrypt: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"er: data_buf out of bounds, data_buf %p, erso_buf %p, erso_buf_len 0x%llx, extent_len 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s er: error read unrolled data %llx, %llu %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d writing recovery data, recovery_data_len 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"er: checksum out of bounds, checksum_buf %p, checksums_len 0x%llx, erso_recovery_buf %p, recovery_buf_max_size 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s er: fsroot: error writing rolled data %llx, %llu %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_write_rolled_extents",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s reached end of list, numMappings %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s An unexpected dirty mapping found @ %llx->%llx, %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_roll_window",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "er_lookup_and_compare_file_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_lock_and_compare_file_extents",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s mismatch when verifying fusion locked extents, idx 0x%llx, pbn 0x%llx, len 0x%llx, count 0x%llx, num_mappings 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s fusion_mt_er_verify_extent_mappings returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"er: number of fusion mappings during verify 0x%llx exceeded number of mappings 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s mismatch when verifying fusion locked extents, num_mappings 0x%llx, locked_num_mappings 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: mismatch, reached end of list, numMappings %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: mismatch @idx%llu, expected: lba %llx, mappedLba %llx, length %llu, current: lba %llx, mappedLba %llx, length %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_er_fusion_verify_locked_extents",
            "prototype": "",
            "backtrace": [
                "_er_roll_window"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s could not enter tx while clearing recovery, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_clear_recovery",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d when deleting recovery\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Failed to leave tx while clearing recovery: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_clear_recovery",
            "prototype": "",
            "backtrace": [
                "_er_roll_window"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error finishing fusion roll for extent, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s er: fsroot: updating blockmap for range %llx, %llu %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error %d checking if current fext is rolled during decrypt: obj_id 0x%llx, logical_addr 0x%llx, len 0x%llx, pbn 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Skip deleted fext update: obj_id 0x%llx, logical_addr 0x%llx, len 0x%llx, pbn 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error updating fext for decrypt: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_fusion_finish_roll_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error restoring MT mapping %llx -> %llx, %llu: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error %d getting bitmap state for fext: obj_id 0x%llx, logical_addr 0x%llx, len 0x%llx, pbn 0x%llx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_is_fext_rolled",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_roll_window_post_roll",
            "prototype": "",
            "backtrace": [
                "_er_roll_window"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: invalid time estimate progress, last 0x%llx, current 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: invalid time estimate timestamp, last 0x%llx, current 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_reset_window",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s er: fext: finish: error rolling remaining extents, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "er_roll_and_reset_window",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_roll_and_reset_window",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: low-memory condition -- sleeping for 1 second and retrying...\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: MARKING VOLUME '%s' FAILED DUE TO ERROR %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: UNABLE TO MARK VOLUME '%s' AS ER-FAILED: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_er_fs_root_iterator_error_check",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "aks_new_ekwk_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "new_ekwk_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_new_skey",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "wrapped_ek->key == skey_get_ek(key)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ek_len <= skey_ek_len(key)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "wrapped_ek->dp_class == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_return_skey_ek",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "wrapped_ekwk->key == skey_get_ekwk(key)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "ekwk_len <= skey_ekwk_len(key)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "((cp_key_class_t)(0x0000001f & (skey_get_class(key)))) == ((cp_key_class_t)(0x0000001f & (wrapped_ekwk->dp_class)))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_return_skey_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "borrowed->key == cpx_key(ek)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "len <= cpx_max_key_len(ek)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "iv_key_len == 16",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_return_ek",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "borrowed->key == ekwk->key",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "len <= ekwk->capacity",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_return_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "aks_unwrap_ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "unwrap_ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_unwrap_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "aks_unwrap_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "unwrap_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_unwrap_ek",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "aks_rewrap_ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "rewrap_ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_rewrap_ekwk",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "aks_rewrap_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "rewrap_ek",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_rewrap_ek",
            "prototype": "",
            "backtrace": [
                "_clone_split_fext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"obj-id %llu still has refcount %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_crypto_cache_purge_freelist_locked",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"crypto object retain count %d is not valid (crypto-id %lld, apfs %p)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_decrement_crypto_refcount",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s couldn't read checkpoint descriptor block %d @ 0x%llx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_checkpoint_desc_block_address"
                },
                {
                    "string": "nx_checkpoint_find_highest_xid",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_checkpoint_desc_block_address"
                },
                {
                    "string": "%s:%d: %s found unexpected object type 0x%x @ checkpoint descriptor block %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s invalid checksum for object type 0x%x @ checkpoint descriptor block %d @ 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found unexpected subtype 0x%x for object type 0x%x @ checkpoint descriptor block %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s found unexpected xid %lld @ checkpoint descriptor block %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_checkpoint_find_highest_xid",
            "prototype": "",
            "backtrace": [
                "_nx_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_check_checkpoint_map_block",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_nx_checkpoint_validate_checkpoint_map_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s<->superblock mismatch on uuid\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_superblock_agrees_with_main_superblock",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on fusion uuid, tier2=%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: the %s superblock has a lower XID %lld than the main superblock %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on block size: %d %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on block count: %lld %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on checkpoint descriptor block count: %d %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on checkpoint data block count: %d %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on checkpoint descriptor base address: %lld %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s<->superblock mismatch on checkpoint data base address: %lld %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_superblock_agrees_with_main_superblock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s Couldn't get apfs oid %llu, fsidx %u, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                },
                {
                    "string": "nx_destroy_incompletely_restored_volumes",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                },
                {
                    "string": "%s:%d: %s Couldn't delete apfs oid %llu, fsidx %u, err %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_get"
                }
            ],
            "symbol": "_nx_destroy_incompletely_restored_volumes",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s non writable nx dev: r/w update not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s unsupported nx_readonly_compatible_features (0x%llx): r/w update not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s hibernate unlock mode: r/w update not allowed\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to clear RC stash, %d %s",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error getting address of checkpoint superblock at index %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s nx_unblock_physical_range failed with error %d for range (%lld, %lld)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__ZL27upgrade_container_if_neededP8nx_entryP11vfs_context",
            "prototype": "",
            "backtrace": [
                "_container_load"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s couldn't allocate memory for checkpoint map block\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't read checkpoint descriptor map block %d @ %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s couldn't read checkpoint data block %d @ %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unexpected checkpoint map entry address: 0x%llx, expected 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s checkpoint mapping (%d,%d) extends beyond checkpoint data range: %d,%d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to load checkpoint data of type 0x%x:0x%x @ %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_checkpoint_get",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_nx_checkpoint_load_data",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to freeze transactions before issuing TRIMs: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to start the TRIM-issuing thread\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_mount_initiate_free_space_trims",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"obj_cache_lock_by_state, invalid oc_lock_state %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_cache_lock_by_state",
            "prototype": "",
            "backtrace": [
                "_obj_get"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"obj_cache_unlock_by_state, invalid oc_lock_state %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_cache_unlock_by_state",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 3,
            "anchors": [
                {
                    "string": "\"non-virtual object on virtual object dirty list: oid %lld flags 0x%llx 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"virtual object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"virtual object dirty count underflow\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"non-physical object on physical object dirty list: oid %lld flags 0x%llx 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"physical object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"physical object dirty count underflow\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_cache_flush_prepare",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"bad object type in flush list: oid %lld flags 0x%llx 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_cache_flush_unprepare",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "nx_oc_obj_cache_flush_write",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_mtx_lock"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error writing: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_cache_flush_write",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_cache_flush_write",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s removing reverted fs objects for fs %lld: %lld - %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - is dirty\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - has refs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_obj_cache_remove_reverted_fs_objects",
            "prototype": "",
            "backtrace": [
                "_omap_reap"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x/0x%x: attempt to perform async fetch without proper init args\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_get",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"o %p, failed to lock ref, refs 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_get",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx is not ephemeral\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s checkpoint area out of space: stable: %d %d - next %d %d available %d %d tx[%lld] %d %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_checkpoint_space_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write checkpoint map block %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error getting next checkpoint map block address %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error getting next checkpoint data block address %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to write checkpoint data block %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"not handling the flushing tx!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"not handling the current tx!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"current tx not closed/flushing?!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s tx xid %lld was closed for %lld us waiting to prepare to flush\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s xid %lld error preparing to flush object cache: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx xid %lld took %lld us to prepare to flush\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s xid %lld error getting first checkpoint map block address %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld error preparing ephemeral object (oid 0x%llx type 0x%x/0x%x): %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unknown NEW persistent ephemeral object found: oid 0x%llx type 0x%x/0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tx_barrier_internal"
                },
                {
                    "string": "%s:%d: %s xid %lld error getting next checkpoint superblock address %d: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld checkpoint descriptor count is larger than expected: %d > %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld checkpoint data block count is larger than expected: %d > %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld error flushing objects from the cache: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to write checkpoint data @ 0x%llx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to write last checkpoint map block %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"flush phase checkpoint lengths (%d %d) don't match prepare phase (%d %d)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s tx xid %lld took %lld us to flush\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s xid %lld sync/barrier failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to write checkpoint superblock %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to write block 0 superblock: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %lld failed to write superblock to fusion tier2 device block 0: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s tx xid %lld took %lld us to sync and write superblock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s xid %lld second sync/barrier failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s xid %llu tx stats: # %llu finish %llu enter %llu wait %llu %lluus close %lluus flush %lluus\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Failed to resume Fusion Elevator on container %s: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s dirty work: flushing %lld bytes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s skipping ubc_msync on vp %p because fs is locked\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_flush",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"invalid lock flags: 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_lock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"invalid unlock flags: 0x%x\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_unlock",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x can't modify object before read completes\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_oc_obj_modify",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_OSBitOrAtomic"
                },
                {
                    "string": "\"can't modify o %p on encrypted and locked fs %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error allocating new location %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old space @ 0x%llx: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_modify",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "obj_checkpoint_start",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_obj_checkpoint_start",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "obj_checkpoint_done",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": null
                }
            ],
            "symbol": "_obj_checkpoint_done",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "obj_checkpoint_known",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_obj_checkpoint_known",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Unknown object loaded from checkpoint: oid 0x%llx type 0x%x/0x%x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "obj_checkpoint_check_for_unknown",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_obj_checkpoint_check_for_unknown",
            "prototype": "",
            "backtrace": [
                "_nx_mount"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error getting mapping to write %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid %lld flags 0x%llx 0x%x type 0x%x/0x%x xid %lld (cur xid %lld) error allocating space to write %d; blkcount %d (o_size_phys %d) paddr %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error setting mapping for write %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error deleting old mapping %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old location %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_write_prepare",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Object has no address: o %p oid %llu flags 0x%llx 0x%x paddr %llu naddr %llu\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: %s can not write an object for an fs that is encrypted and locked! (nx %s %d 0x%llx apfs %p 0x%llx 0x%llx %lld o %p 0x%llx 0x%x:0x%x)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_write_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_write_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed: cksum 0x%016llx, oid 0x%llx, o_xid 0x%llx, o_type 0x%x, o_subtype 0x%x, size %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_checksum_verify",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s flags 0x%x type 0x%x/0x%x error allocating new physical location %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s flags 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_create_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error destroying: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_alloc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_alloc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error destroying: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "obj_destroy_complete",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"object to be freed is on a list, o %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx list %p/%p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_destroy_complete",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"can not delete an object w/a non-current xid %lld o == %p\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_delete_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"o %p, failed to get ref, allow_wait %d, ref_acquired %d, reflock_out_flags 0x%x, flags 0x%llx, refs 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_ref_count_increment_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"o %p, invalid reflock_try_get_ref out_flags 0x%x, flags 0x%llx, refs 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_reference_release_wait",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"o %p, failed to put ref, reflock_out_flags 0x%x, flags 0x%llx, refs 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_ref_count_decrement_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s wrong object - wanted oid 0x%llx type 0x%x:0x%x xid %lld - got oid 0x%llx type 0x%x:0x%x xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_obj_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"deleted object @ %p can not be dirtied!! (flags: 0x%llx)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x bad dirty xid: 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object not prepared before dirtying\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"new address mismatch on redirty 0x%llx 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"virtual object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"physical object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"physical object new address mismatch: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "\"obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x dirty object on the free list?!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_dirty_locked",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "\"metadata rolling is unsupported for \" \"secondary fs_root tree\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_obj_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 2,
            "anchors": [
                {
                    "string": "%s:%d: %s error adding omap 0x%llx type 0x%x to reap list: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "omap_destroy",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_omap_destroy",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s error adding omap 0x%llx type 0x%x to reap list for cleaning: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to find snapshot %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__omap_snapshot_delete",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to create snapshot for reversion: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Unable to look up any snapshot greater than %lld ?: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_omap_revert_to_snapshot",
            "prototype": "",
            "backtrace": [
                "_revert_to_snapshot"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s cancelling eviction of omap range mappings\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s oid %lld xid %lld, ov flags 0x%x paddr 0x%llx current object: flags 0x%llx 0x%x paddr 0x%llx, waiting on write\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Error evicting oid %lld xid %lld, obj_write() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error Evicting oid %lld xid %lld, obj_get() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error evicting oid %lld, obj_write() returned %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_omap_evict_range_mappings",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "omap_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_omap_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s obj_modify() failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get omap tree for reaping: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman_free(%lld, %lld) failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to get omap snapshot tree for reaping: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error modifying omap: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error getting mapping tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s started cleaning snapshots %lld-%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s error deleting empty snapshot tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_omap_reap",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to create snapshot tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error adding snapshot: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "__omap_snapshot_create",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "(fext->logical_addr <= off) && (off <= fext_lend(fext))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fext_blockat",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!((end - start) % fs_bsize)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(end - start) < ((1ULL << (56)) - 1)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "off_in_fext(off, fext)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fext_cut",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "remove_fext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                },
                {
                    "string": "(fext_sanitize(fext))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_remove_fext",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: spaceman_free (%llx, %lld) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_rc_update_alloc_accounting (%lld) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_remove_range_deallocate_rc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Range [%llx, %llu] is marked as deleted (dirty: %u) and would not be inserted\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "fusion_mt_insert",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_fusion_mt_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s extent length is zero for fext id %llu, offs %llu, LBA %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_read_extent",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_read_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: MT iteration failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_evict",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: fusion_mt_get_mapped_extent failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_insert_int(%llx->%llx, %llu, clean, owner) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_remove_range_deallocate_rc(%llx, %llu, dirty) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_insert_int(%llx->%llx, %llu, clean, tenant) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_remove_range(%llx, %llu, wbc) failed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: fusion_mt_remove_range_deallocate_rc(%llx,%llu,dirty) failed on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_elevator_unmap_mapped_extent",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Verify MT->revMT\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "fusion_mt_validate",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: Verify revMT->MT\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_fusion_mt_validate",
            "prototype": "",
            "backtrace": [
                "_handle_fusion_debug",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to create a reverse middle tree on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_get_tree_WRITE",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_get_tree_WRITE",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Dirty extent should not have Tenant flag\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_mt_insert_int",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Range (0x%llx,%llu) is intersecting WBC (0x%llx,%llu)\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_fusion_mt_is_extent_outside_wbc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to update extent %llx->%llx, %u on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_remove_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: Failed to insert extent %llx->%llx, %u : %d %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_remove_range_insert_tail",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_remove_range_insert_tail",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: failed to get middle tree on %s with %u %s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "fusion_mt_get_tree",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_get_tree",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: A hole in [%llx, %llx]\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Mismatch in [%llx -> %llx, %u] @ +%llu %llx != %llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: Flags mismatch in [%llx -> %llx, %u] @ +%llu %x != %x\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_fusion_mt_compare",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s nx_unmount detected while processing dev=%d cib=%u out of %u cibs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s nx_resize detected while processing dev=%d cib=%u out of %u cibs\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s failed to evaluate chunk %llu (average free ext len %u) for disabled allocation zones, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to evaluate free chunk %llu for disabled allocation zone, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_iterate_free_extents_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s scan took %lld.%06lld s, trims took %lld.%06lld s\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %lld blocks free in %lld extents\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s %lld blocks trimmed in %lld extents (%lld us/trim, %lld trims/s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s trim distribution 1:%lld 2+:%lld 4+:%lld 16+:%lld 64+:%lld 256+:%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s scan took %lld.%06lld s (no trims)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_scan_free_blocks",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s can't get spaceman %d free queue tree %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s error searching spaceman free queue tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s block range %lld:%lld out of %s bounds %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %lld:%lld error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_check_allocation_status_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be freed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_free",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s can't reserve metadata block(s) nx->nx_allocations_not_yet_updated_on_host %lld raw free space %llu (count %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_reserve",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_reserve",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Quota %llu is smaller than reserve %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Quota %llu is smaller than what's currently allocated and reserved %llu\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s %llu blocks are already reserved in container, Cannot reserve more than %llu blocks in the container\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sm_fs_reserve_alloc_count underflow, sm_fs_reserve_alloc_count %lld, new fs_reserve_block_count %lld, old fs_reserve_block_count %lld alloc_count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fs_bounds_set",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s file system %lld alloc block count is not zero: %lld/%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_fs_bounds_clear",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s file system %lld fs reserve block count %lld larger than global fs reserve block count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s file system %lld fs reserve alloc count %lld larger than global fs reserve alloc count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fs_bounds_clear",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s max_available_space %lld currently_allocated %lld currently_allocated_in_fixed_fs %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "spaceman_get_max_allowed_shrink",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s sm_free_count: [MAIN]=%lld, [TIER2]=%lld    sm_reserved_space: [MAIN]=%lld, [TIER2]=%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s sm_fs_reserve_block_count %lld, sm_fs_reserve_alloc_count %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Used space move overhead is %lld (based on shrink_amount %lld and currently_allocated %lld), setting max_allowed_shrink to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s Minimal free space threshold_blocks is %lld, updating max_allowed_shrink to %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_get_max_allowed_shrink",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s spaceman_count_free_in_range(%lld, %lld) failed with error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Do not defragment the metadata zone. Decrementing pr_block_count with %lld blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: %s requested to evict %lld which is larger than max allowed eviction range %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                }
            ],
            "symbol": "_spaceman_set_block_out_range",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get next metadata range, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Free count in blocked-out range %lld, sm objects size %lld, out of %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_spaceman_is_block_out_range_free",
            "prototype": "",
            "backtrace": [
                "_nx_block_out_physical_range_internal"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s range (%lld) is smaller than blocks per chunk (%u)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_set_soft_block_out_range",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "spaceman_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_spaceman_init",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "spaceman_cab_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_spaceman_cab_sanity_check",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "spaceman_cib_sanity_check",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_corrupt"
                }
            ],
            "symbol": "_spaceman_cib_sanity_check",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s free extent %lld:%lld appears to span container metadata and should not be free: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_trim_free_extent_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_trim_free_extent_callback",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get next internal pool reverse mapping, error %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_set_up_ip_reverse_mapping_tree",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_ip_block_index",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "spaceman_ip_bm_block_alloc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_spaceman_ip_bm_block_alloc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to find free IP block or to free pending free IP blocks\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_ip_block_alloc",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_ip_block_alloc",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "spaceman_ip_bm_block_free",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_nx_corruption_detected_int"
                }
            ],
            "symbol": "_spaceman_ip_bm_block_free",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "trim_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "%s:%d: %s sfq %d entry %lld:%lld %lld - bad xid, current xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sfq %d processing xid %lld blocked by temporary checkpoints %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_info"
                },
                {
                    "string": "%s:%d: %s sfq %d error validating extent %lld %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sfq %d error removing entry %lld %lld from free queue: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s sfq %d error inserting shortened entry %lld %lld into free queue: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_free_completed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s sfq %d count underflow %lld - %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_decrement_free_queue_count",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_decrement_free_queue_count",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s attempt to free block(s) outside of internal pool: 0x%llx:0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error mapping freed IP block range 0x%llx:0x%llx to index: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_ip_freed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to create bitmap object %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s freeing 0x%llx:%lld, but %lld bits are already clear.  Double free?\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_clear_bits_in_bm",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_modify_bits",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be free: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "spaceman_freed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_freed",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s fs %lld alloc count underflow: %lld (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s spaceman fs reserve alloc count underflow: %lld (%lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_free_fs_deduct_block_counts",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s removal of replaced free extent failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_spaceman_fq_tree_insert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Trash unfinished tx xid=0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_mgr_free_tx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Trash unfinished pending tx, xid range = 0x%llx - 0x%llx\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_mgr_free_tx",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to get fs_private tx_active, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_need_to_expedite_meta_io",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_need_to_expedite_meta_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s xid mismatch (%lld != %lld), unable to add dirty work for vp %p %lld:%lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_add_dirty_work_item",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_add_dirty_work_item",
            "prototype": "",
            "backtrace": [
                "_fs_map_file_offset_ext"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s freezing tx system took %u iterations (start xid %lld cur xid %lld; delta %lld)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_freeze",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_freeze",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "nx_tx_finish_wait_for_dirty_data",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_wakeup"
                },
                {
                    "string": "tx_finish",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_tx_finish",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "tx_leave",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                },
                {
                    "string": "%s:%d: %s failed to decrement fs_private tx_active, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_remove_active",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_leave",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s dirty_work_flush_size went negative!  i %d len %lld flush_size %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_vnode_drop"
                },
                {
                    "string": "remove_dirty_work_item_if_present",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_remove_dirty_work_item_if_present",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s tx_flush(%lld) failed, %d, # %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "nx_tx_flush_idle",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                }
            ],
            "symbol": "_tx_flush_thread",
            "prototype": "",
            "backtrace": [
                "_tx_flush_thread_wakeup"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"Thread %llx is already in tx, but is trying to enter a transaction without providing the current XID!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "nx_tx_wait",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                },
                {
                    "string": "nx_tx_wait_closing",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                },
                {
                    "string": "nx_tx_wait_closed_prev_flushing",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                },
                {
                    "string": "nx_tx_wait_closed",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                },
                {
                    "string": "nx_tx_wait_flush",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_tm_cv_wait"
                },
                {
                    "string": "%s:%d: %s tx %p w/xid %lld has a non-zero dirty work count %d!\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_enter_internal",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_checksum_set"
                },
                {
                    "string": "%s:%d: %s Error: tx[%lld] failed to unclean superblock: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s Error: tx[%lld] failed to start: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s waiting for available tx to open: xid %lld\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_checksum_set"
                },
                {
                    "string": "nx_tx_wait_open",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_obj_checksum_set"
                },
                {
                    "string": "%s:%d: %s waited %lld us to open tx xid %lld (%s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_warn"
                }
            ],
            "symbol": "_tx_enter_internal",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to increment fs_private tx_active, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "tx_add_active",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_tx_add_active",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: unable to allocate resources for specread free queue\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to allocate resources for specread queue lock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_specread_threads",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_PE_parse_boot_argn"
                },
                {
                    "string": "%s:%d: number of threads used for specread work queue %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                },
                {
                    "string": "%s:%d: could not start specread kernel thread\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to allocate memory for specread free info buffer\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "specread_free_queue_init",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to allocate memory for specread lock attr\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_specread",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_grp_alloc_init"
                },
                {
                    "string": "%s:%d: unable to allocate memory for specread lock grp\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: unable to allocate memory for specread queue lock\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_specread_work_queue_init",
            "prototype": "",
            "backtrace": [
                "_internal_module_resources"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: no free info buffer available, requested file content will not be preloaded\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "specread_enqueue_work",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_specread_enqueue_work",
            "prototype": "",
            "backtrace": [
                "_handle_speculative_read",
                "_apfs_vnop_ioctl",
                "_apfs_stream_vnop_ioctl"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: cannot re-validate vnode %p with vid %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s failed to fetch uncompressed file size of inode %lld: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: low on memory, requested file content will not be preloaded\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: device is going away, requested file content will not be preloaded\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s request to speculatively pagein %lld bytes of %sdata at offset %lld of inode %lld failed: %s(%d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_specread_do_work",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"how odd... there is nothing at the tail of the dir iterator list yet the count is %d\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_save_dir_iterator",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "free_all_iterators",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_debug"
                }
            ],
            "symbol": "_free_all_iterators",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "(ret == UIO_READ) || (ret == UIO_WRITE)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_uio_is_read",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "cluster_off_in_fext(off, fext, fs_bsize)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_cluster2off",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "fake-xattr-ino",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_snprintf"
                },
                {
                    "string": "%s:%d: %s failed vnode_ref for %lld! (err %d)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_create_empty_xattr_vnode",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"bad xattr vnode context! xattr_dstream_id 0x%llx\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "apfs_xattr_no_ctx_available",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_lck_mtx_lock"
                },
                {
                    "string": "apfs_xattr_need_same_ctx",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_msleep"
                },
                {
                    "string": "\"xattr vnode does not exist; so we cannot do any xattr IO\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_get_xattr_context",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"did not find xattr ctx for xattr %llu to release it!\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_release_xattr_context",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "\"offset %lld not found in apfs_xattr_io_ctxes, or wasn't in use\\n\" @%s:%d",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_get_fext_for_xattr_io",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "uio_offset(uio) == 0",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(0 <= resid) && (resid <= 18446744073709551615UL)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_xattr_uio_assert",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "!ret->fext",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "!ret->ekwk",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_xattr_fext_alloc",
            "prototype": "",
            "backtrace": [
                "_xattr_io2"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "bm_valid_index(from, len)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "bm_valid_index(i, len)",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_bm_find",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "xbm_valid_index(info, xattr_fext_index(info, xfext))",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "(info->xattr_fexts <= xfext) && (xfext < &info->xattr_fexts[xbm_size(info)])",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "%s:%d: xattr %s, uio %lld:+%lld, %llu, failed with EINVAL\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "cluster_xattr",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_xattr_io2",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "iter->i < iter->len",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_xattr_fext_find",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s Failed to iterate directory %lld, error %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_is_dir_empty",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_is_dir_empty",
            "prototype": "",
            "backtrace": [
                "_apfs_vnop_rmdir_with_flags"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s failed to create dstream on ino %lld (isreg: %s)\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "apfs_set_file_size",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_apfs_set_file_size",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "apfs_io_lock_exclusive",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                },
                {
                    "string": "fs_utils.c",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_panic"
                }
            ],
            "symbol": "_apfs_io_lock_exclusive",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 1,
            "anchors": [
                {
                    "string": "%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "omap_recent_sanity_callback",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_omap_recent_sanity_callback",
            "prototype": "",
            "backtrace": [
                "_nx_check_recent_sanity_omap"
            ]
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to read cab %d @ %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to read cib %lld @ %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap check failed with error: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get fs[%d] oid %lld, %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get omap %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s omap check failed for omap %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get extentref tree %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s extentref tree %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get snap meta tree %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s snap meta tree %lld: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_check_recent_sanity",
            "prototype": "",
            "backtrace": []
        },
        {
            "args": 0,
            "anchors": [
                {
                    "string": "%s:%d: %s unable to get omap tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                },
                {
                    "string": "%s:%d: %s unable to get omap snapshot tree: %d\n",
                    "segment": "__TEXT",
                    "section": "__cstring",
                    "caller": "_log_err"
                }
            ],
            "symbol": "_nx_check_recent_sanity_omap",
            "prototype": "",
            "backtrace": []
        }
    ]
}